(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["main"],{

/***/ "./src/js/appJupyter.js":
/*!******************************!*\
  !*** ./src/js/appJupyter.js ***!
  \******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _graph_main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph/main */ \"./src/js/graph/main.js\");\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data/config */ \"./src/js/data/config.js\");\n\n\n\nfunction keyboardPressFunction(key, action) {\n  switch (action) {\n    case \"deleteNode\":\n      //let pickedObjectsNames = cameraObj.pickedObjects;\n      //if (pickedObjectsNames.length>0) {\n      //cameraObj.deleteHelpers();\n      //Config.vimMode = \"Visual\"\n      //dataPoolSocket.deleteNodes(pickedObjectsNames);\n      //pickedObjectsNames.map(nodeId=>nodes0.deleteNode(nodeId));\n      ////pickedObjectsNames.map(=>edges0.deleteByNode(nodeId));\n      //cameraObj.unpick();\n      //}\n      //render()\n      break;\n\n    case \"move\":\n      //let p = 0.1\n      //let dr = {\n      //\"l\" :[p, 0, 0],\n      //\"j\" :[-p, 0 ,0],\n      //\"i\": [0, p, 0],\n      //\"k\": [0, -p, 0]\n      //}[key.toLowerCase()]\n      //let pWorld =  new THREE.Vector3( dr[0], dr[1], -1 ).unproject( camera );\n      //nodes0.moveNodes({}, cameraObj.pickedObjects, dr)\n      //render()\n      break;\n\n    case \"recalcPos\":\n      //dataPoolSocket.recalcPos()\n      break;\n\n    case \"reloadGraph\":\n      //dataPoolSocket.reloadGraph()\n      break;\n\n    default:\n      break;\n  }\n}\n\nfunction listenerFunction(event) {\n  var message = JSON.parse(event.data);\n\n  switch (message[\"type\"]) {\n    case \"getGraph\":\n      clearInterval(intervalGetGraph); //graphObj.state.defaultProps = message.defaultProps\n\n      graphObj.nodes.createNodes(message.nodes, message.defaultProps);\n      graphObj.edges.createEdges(message.nodes, message.edges, message.defaultProps);\n\n      if (graphObj.state.firstLoad) {\n        graphObj.firstLoad = false;\n        graphObj.ressetLook();\n        clearInterval(intervalGetGraph);\n      } //\n      //camera.position.set(0, nodes0.max_vals[2] * (1 + 2), 0);\n      //datGui.updateNodeColorProp(message.nodes.props)\n      //datGui.updateEdgeColorProp(message.edges.props)\n      //camera.lookAt(nodes0.instancedNodes);\n\n\n      break;\n\n    case \"deleteNodes\":\n      //message.info.nodesId.map(nodeId=>nodes0.deleteNode(nodeId));\n      //message.info.edgesName.map(edgeName=>edges0.deleteEdge(edgeName));\n      ////dataPoolSocket.recalcPos();\n      ////\n      //render()\n      break;\n\n    case \"updatePos\":\n      graphObj.nodes.updateNodePositions(message.info.pos);\n      graphObj.edges.updateNodePositions(message.info.pos);\n      graphObj.renderer.render();\n      break;\n\n    default:\n      break;\n  }\n}\n\nvar graphObj = new _graph_main__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"appContainer\", _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"], keyboardPressFunction);\ngraphObj.init();\nwindow.teste = \"testando123\";\nwindow.graphObj = graphObj;\nalert(\"importado\");\n\n//# sourceURL=webpack:///./src/js/appJupyter.js?");

/***/ }),

/***/ "./src/js/data/config.js":
/*!*******************************!*\
  !*** ./src/js/data/config.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  address: \"127.0.0.1:6688\",\n  scene: {\n    color: 0xe9e9ff\n  },\n  isDev: true,\n  render: {\n    antialias: true\n  },\n  isShowingStats: true,\n  isLoaded: false,\n  isMouseMoving: false,\n  isMouseOver: false,\n  maxAnisotropy: 2,\n  dpr: 1,\n  layers: {\n    0: {},\n    1: {\n      enabled: true,\n      clearColor: 0x000000,\n      exposure: 1,\n      strength: 0.5,\n      bloomStrength: 5,\n      bloomThreshold: 0,\n      bloomRadius: 0\n    },\n    2: {},\n    3: {\n      enabled: false,\n      exposure: 1,\n      clearColor: 0x000000,\n      strength: 0.5,\n      bloomStrength: 5,\n      bloomThreshold: 0,\n      bloomRadius: 0,\n      scene: \"Scene with Glow\"\n    }\n  },\n  nodes: {\n    material: \"fast\",\n    scale: 1,\n    show: true,\n    radius: .5,\n    color: 0x0000ff,\n    roughness: 0.5,\n    opacity: 1\n  },\n  edges: {\n    show: true,\n    color: 0x0000ff,\n    roughness: 0.5,\n    opacity: 1\n  },\n  fog: {\n    color: 0xffffff,\n    near: 0.0008\n  },\n  camera: {\n    fov: 40,\n    near: 2,\n    far: 1000,\n    aspect: 1,\n    posX: 0,\n    posY: 30,\n    posZ: 40\n  },\n  controls: {\n    autoRotate: false,\n    autoRotateSpeed: -0.5,\n    rotateSpeed: 0.5,\n    zoomSpeed: 0.8,\n    minDistance: 0,\n    maxDistance: 600,\n    minPolarAngle: 0,\n    maxPolarAngle: Math.PI,\n    minAzimuthAngle: -Infinity,\n    maxAzimuthAngle: Infinity,\n    enableDamping: true,\n    dampingFactor: 0.5,\n    enableZoom: true,\n    target: {\n      x: 0,\n      y: 0,\n      z: 0\n    }\n  }\n});\n\n//# sourceURL=webpack:///./src/js/data/config.js?");

/***/ }),

/***/ "./src/js/graph/components/controls.js":
/*!*********************************************!*\
  !*** ./src/js/graph/components/controls.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Controls; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _utils_orbitControls__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/orbitControls */ \"./src/js/utils/orbitControls.js\");\n/* harmony import */ var _utils_orbitControls__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_utils_orbitControls__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../data/config */ \"./src/js/data/config.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n // Controls based on orbit controls\n\nvar Controls = /*#__PURE__*/function () {\n  function Controls(camera, container, render) {\n    _classCallCheck(this, Controls);\n\n    // Orbit controls first needs to pass in THREE to constructor\n    var orbitControls = new _utils_orbitControls__WEBPACK_IMPORTED_MODULE_1___default.a(three__WEBPACK_IMPORTED_MODULE_0__);\n    this.threeControls = new orbitControls(camera, container); //this.threeControls.addEventListener('change', render);\n\n    this.threeControls.addEventListener('change', render);\n    this.init();\n  }\n\n  _createClass(Controls, [{\n    key: \"init\",\n    value: function init() {\n      this.threeControls.target.set(_data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.target.x, _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.target.y, _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.target.z);\n      this.threeControls.autoRotate = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.autoRotate;\n      this.threeControls.autoRotateSpeed = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.autoRotateSpeed;\n      this.threeControls.rotateSpeed = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.rotateSpeed;\n      this.threeControls.zoomSpeed = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.zoomSpeed;\n      this.threeControls.minDistance = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.minDistance;\n      this.threeControls.maxDistance = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.maxDistance;\n      this.threeControls.minPolarAngle = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.minPolarAngle;\n      this.threeControls.maxPolarAngle = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.maxPolarAngle;\n      this.threeControls.enableDamping = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.enableDamping;\n      this.threeControls.enableZoom = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.enableZoom;\n      this.threeControls.dampingFactor = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.dampingFactor;\n    }\n  }]);\n\n  return Controls;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/graph/components/controls.js?");

/***/ }),

/***/ "./src/js/graph/components/edges/main.js":
/*!***********************************************!*\
  !*** ./src/js/graph/components/edges/main.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Edges; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var colormap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! colormap */ \"./node_modules/colormap/index.js\");\n/* harmony import */ var colormap__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(colormap__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var alertifyjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! alertifyjs */ \"./node_modules/alertifyjs/build/alertify.js\");\n/* harmony import */ var alertifyjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(alertifyjs__WEBPACK_IMPORTED_MODULE_2__);\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\nvar Edges = /*#__PURE__*/function () {\n  function Edges(scene, layer, bloomLayer) {\n    _classCallCheck(this, Edges);\n\n    this.createEdges = this.createEdges.bind(this);\n    this.scene = scene;\n    this.layer = layer;\n    this.bloomLayer = bloomLayer;\n    this.numEdges = 0;\n    this.edgesData = {};\n    this.instancedEdges;\n  } //deleteByNode(nodeId){\n  //}\n\n\n  _createClass(Edges, [{\n    key: \"updateNodePositions\",\n    value: function updateNodePositions(positions) {\n      var positionVertices = []; //A simple arrow function  in order to clean the code\n\n      var f = function f(arr, index) {\n        return arr.push.apply(arr, _toConsumableArray([0, 1, 2].map(function (i) {\n          return positions[index + i];\n        })));\n      };\n\n      var _iterator = _createForOfIteratorHelper(this.edgesData.nodes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              s = _step$value[0],\n              t = _step$value[1];\n\n          var id_s = s * 3;\n          var id_t = t * 3; //positionVertices.push(\n          //positions[id_s],\n          //)\n\n          f(positionVertices, id_s);\n          f(positionVertices, id_t);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.instancedEdges.geometry.attributes.position.array = new Float32Array(positionVertices);\n      this.instancedEdges.geometry.attributes.position.needsUpdate = true;\n      this.instancedEdges.geometry.computeBoundingSphere();\n    }\n  }, {\n    key: \"colorByProp\",\n    value: function colorByProp(prop) {\n      var colors = colormap__WEBPACK_IMPORTED_MODULE_1___default()({\n        colormap: \"jet\",\n        nshades: this.numEdges,\n        format: \"float\",\n        alpha: 1\n      });\n      var values = this.edgesData[prop];\n      var bufferColors = colors.map(function (color, index) {\n        return [values[index], color];\n      }) // add the prop to sort by\n      .sort(function (_ref, _ref2) {\n        var _ref3 = _slicedToArray(_ref, 1),\n            val1 = _ref3[0];\n\n        var _ref4 = _slicedToArray(_ref2, 1),\n            val2 = _ref4[0];\n\n        return val2 - val1;\n      }) // sort by the prop data\n      .map(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            color = _ref6[1];\n\n        return color;\n      }).map(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 4),\n            r = _ref8[0],\n            g = _ref8[1],\n            b = _ref8[2],\n            alpha = _ref8[3];\n\n        return [r, g, b, r, g, b];\n      }).flat();\n\n      if (bufferColors.length != this.numEdges * 6) {\n        alertifyjs__WEBPACK_IMPORTED_MODULE_2___default.a.error(\"Invalid prop\");\n        alert(\"prop fail\");\n        return;\n      }\n\n      this.instancedEdges.geometry.attributes.color.array = new Float32Array(bufferColors);\n      this.instancedEdges.geometry.attributes.color.needsUpdate = true;\n      this.instancedEdges.material.needsUpdate = true;\n    }\n  }, {\n    key: \"changeOpacity\",\n    value: function changeOpacity(value) {\n      this.instancedEdges.material.opacity = value; //this.instancedEdges.material.blending=THREE.AdditiveBlending,c\n\n      this.instancedEdges.material.needsUpdate = true;\n    }\n  }, {\n    key: \"ressetVerticesPos\",\n    value: function ressetVerticesPos(nodesData, edgesData) {\n      this.createVertices(nodesData, edgesData);\n      this.updateGeometry();\n    }\n  }, {\n    key: \"updateGeometry\",\n    value: function updateGeometry() {\n      this.edges.geometry.dispose();\n      this.edges.geometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"BufferGeometry\"]().setFromPoints(Object.values(this.vertices));\n    } //deleteEdge(edgeName){\n    //if (!(edgeName in this.segments)) return\n    //let inName = this.segments[edgeName][1]\n    //let outName = this.segments[edgeName][0]\n    //delete this.segments[edgeName]\n    //delete this.vertices[inName]\n    //delete this.vertices[outName]\n    //this.updateGeometry()\n    //}\n\n  }, {\n    key: \"createVertices\",\n    value: function createVertices(nodesData, edgesData, defaultProps) {\n      this.vertices = {};\n      this.segments = {};\n      var positions = [];\n      var colors = [];\n      var r = 800;\n      var color;\n\n      var f = function f(arr, index) {\n        return arr.push.apply(arr, _toConsumableArray([0, 1, 2].map(function (i) {\n          return nodesData.pos[index * 3 + i];\n        })));\n      };\n\n      var _iterator2 = _createForOfIteratorHelper(edgesData.nodes),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              s = _step2$value[0],\n              t = _step2$value[1];\n\n          //let geometry = new THREE.Geometry();\n          //  let i = 0;\n          //if (i<1) return\n          var nodeInId = nodesData.id[s];\n          var nodeOutId = nodesData.id[t]; //let edgeName = `${nodeInId}-to-${nodeOutId}`\n\n          f(positions, t);\n          f(positions, s); //let [x, y, z] = nodesData.pos[t]\n          //positions.push( x, y, z );\n          //[x, y, z] = nodesData.pos[s]\n          //positions.push( x, y, z );\n\n          colors.push(0);\n          colors.push(0);\n          colors.push(1);\n          colors.push(0);\n          colors.push(0);\n          colors.push(1);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this.positions = positions;\n      this.colors = colors;\n    }\n  }, {\n    key: \"createEdges\",\n    value: function createEdges(nodesData, edgesData) {\n      if (this.instancedEdges) {\n        this.instancedEdges.geometry.dispose();\n        this.instancedEdges.material.dispose();\n        this.instancedEdges.geometry.needsUpdate = true;\n        this.instancedEdges.material.needsUpdate = true;\n        this.scene.remove(this.instancedEdges);\n      }\n\n      this.edgesData = edgesData;\n      this.numEdges = this.edgesData.nodes.length;\n      this.createVertices(nodesData, edgesData);\n      var geometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"BufferGeometry\"]();\n      var material = new three__WEBPACK_IMPORTED_MODULE_0__[\"LineBasicMaterial\"]({\n        vertexColors: true,\n        transparent: true,\n        opacity: 0.5,\n        linewidth: 5\n      });\n      geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__[\"Float32BufferAttribute\"](this.positions, 3));\n      geometry.setAttribute('color', new three__WEBPACK_IMPORTED_MODULE_0__[\"Float32BufferAttribute\"](this.colors, 3));\n      geometry.computeBoundingSphere();\n      var edges = new three__WEBPACK_IMPORTED_MODULE_0__[\"Line\"](geometry, material);\n      this.instancedEdges = edges;\n      this.scene.add(edges);\n    }\n  }]);\n\n  return Edges;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/graph/components/edges/main.js?");

/***/ }),

/***/ "./src/js/graph/components/nodes/main.js":
/*!***********************************************!*\
  !*** ./src/js/graph/components/nodes/main.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Nodes; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var colormap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! colormap */ \"./node_modules/colormap/index.js\");\n/* harmony import */ var colormap__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(colormap__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var alertifyjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! alertifyjs */ \"./node_modules/alertifyjs/build/alertify.js\");\n/* harmony import */ var alertifyjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(alertifyjs__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../data/config */ \"./src/js/data/config.js\");\n/* harmony import */ var _shaders__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shaders */ \"./src/js/graph/components/nodes/shaders.js\");\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\nvar Nodes = /*#__PURE__*/function () {\n  function Nodes(scene, layer, bloomLayer) {\n    _classCallCheck(this, Nodes);\n\n    this.createNodes = this.createNodes.bind(this);\n    this.scene = scene;\n    this.layer = layer;\n    this.bloomLayer = bloomLayer;\n    this.numNodes = 0;\n    this.nodesData = {};\n    this.instancedNodes;\n    this.availableMaterials = [\"fast\", \"phong\"];\n  } //updateNodesSingle(nodesData) {\n  //for (const [nodeName, props] of Object.entries(nodesData)){\n  //let node = this.nodes[nodeName];\n  //const pos = props[\"pos\"]\n  //// let node = this.scene.getObjectByName(nodeName)\n  ////   if (node) {\n  //node.position.x = pos[0];\n  //node.position.y = pos[1];\n  //node.position.z = pos[2];\n  //// }\n  //}\n  //}\n  //moveNodes(pickedPos, nodesName, dr ) {\n  //for (let index = 0; index < nodesName.length; index++) {\n  ////for (const [nodeName, props] of Object.entries(nodesData)){\n  ////  let idNode = 0;\n  //let node = this.nodes[nodesName[index]];\n  //let pos = node.position\n  //// let node = this.scene.getObjectByName(nodeName)\n  ////   if (node) {\n  ////node.translateX(10)\n  ////node.position.x = pickedPos// pos.x+dr[0];\n  ////node.position.y = pos.y+dr[1];\n  ////node.position.z = pos.z+dr[2];\n  //// }\n  //}\n  //}\n  //deleteNode(nodeId){\n  //if (!(nodeId in this.nodes)) return\n  //this.scene.remove(this.nodes[nodeId])\n  //delete this.nodes[nodeId]\n  //}\n\n\n  _createClass(Nodes, [{\n    key: \"colorByField\",\n    value: function colorByField(prop) {\n      var bufferColors = JSON.parse(JSON.stringify(this.nodesData[prop].flat()));\n\n      if (bufferColors.length != this.numNodes * 3) {\n        alertifyjs__WEBPACK_IMPORTED_MODULE_2___default.a.error(\"The field should be in rgb format\");\n        return;\n      } //this.instancedNodes.material.fragmentShader = fragmentShader\n\n\n      this.instancedNodes.material.fragmentShader = _shaders__WEBPACK_IMPORTED_MODULE_4__[\"fragmentShader\"];\n      this.instancedNodes.geometry.attributes.bufferColors.array = new Float32Array(bufferColors);\n      this.instancedNodes.geometry.attributes.bufferColors.needsUpdate = true;\n      this.instancedNodes.material.needsUpdate = true;\n    }\n  }, {\n    key: \"colorByProp\",\n    value: function colorByProp(prop) {\n      var colors = colormap__WEBPACK_IMPORTED_MODULE_1___default()({\n        colormap: \"jet\",\n        nshades: this.numNodes,\n        format: \"float\",\n        alpha: 1\n      });\n      var values = this.nodesData[prop];\n      var bufferColors = colors.map(function (color, index) {\n        return [values[index], color];\n      }) // add the prop to sort by\n      .sort(function (_ref, _ref2) {\n        var _ref3 = _slicedToArray(_ref, 1),\n            val1 = _ref3[0];\n\n        var _ref4 = _slicedToArray(_ref2, 1),\n            val2 = _ref4[0];\n\n        return val2 - val1;\n      }) // sort by the prop data\n      .map(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            color = _ref6[1];\n\n        return color;\n      }).map(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 4),\n            r = _ref8[0],\n            g = _ref8[1],\n            b = _ref8[2],\n            alpha = _ref8[3];\n\n        return [r, g, b];\n      }).flat();\n\n      if (bufferColors.length != this.numNodes * 3) {\n        alertifyjs__WEBPACK_IMPORTED_MODULE_2___default.a.error(\"Invalid prop\");\n        alert(\"prop fail\");\n        return;\n      }\n\n      this.instancedNodes.material.fragmentShader = _shaders__WEBPACK_IMPORTED_MODULE_4__[\"fragmentShader\"];\n      this.instancedNodes.geometry.attributes.bufferColors.array = new Float32Array(bufferColors);\n      this.instancedNodes.geometry.attributes.bufferColors.needsUpdate = true;\n      this.instancedNodes.material.needsUpdate = true;\n    }\n  }, {\n    key: \"changeColor\",\n    value: function changeColor(color) {\n      var c = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](color);\n      this.instancedNodes.material.fragmentShader = Object(_shaders__WEBPACK_IMPORTED_MODULE_4__[\"fragmentShaderFixedColor\"])(c);\n      this.instancedNodes.material.needsUpdate = true;\n    }\n  }, {\n    key: \"changeOpacity\",\n    value: function changeOpacity(value) {\n      this.uniforms.bufferOpacity.value = value;\n      this.instancedNodes.material.needsUpdate = true;\n    }\n  }, {\n    key: \"changeScale\",\n    value: function changeScale(value) {\n      this.uniforms.bufferNodeScale.value = value;\n      this.instancedNodes.geometry.needsUpdate = true;\n    }\n  }, {\n    key: \"updateNodePositions\",\n    value: function updateNodePositions(positions) {\n      this.instancedNodes.geometry.attributes.bufferNodePositions.array = new Float32Array(positions);\n      this.instancedNodes.geometry.attributes.bufferNodePositions.needsUpdate = true;\n    }\n  }, {\n    key: \"changeRadius\",\n    value: function changeRadius(value) {\n      this.instancedNodes.geometry.attributes.bufferRadius = value;\n      this.instancedNodes.material.needsUpdate = true;\n    }\n  }, {\n    key: \"createNodes\",\n    value: function createNodes(nodesData) {\n      var numNodes = Object.keys(nodesData.id).length;\n      this.nodesData = nodesData;\n      this.numNodes = numNodes;\n\n      if (this.instancedNodes) {\n        this.instancedNodes.geometry.dispose();\n        this.instancedNodes.material.dispose();\n        this.instancedNodes.geometry.needsUpdate = true;\n        this.instancedNodes.material.needsUpdate = true;\n        this.scene.remove(this.instancedNodes);\n      }\n\n      var baseGeometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"SphereBufferGeometry\"](1, 8, 8);\n      var instancedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"InstancedBufferGeometry\"]().copy(baseGeometry);\n      instancedGeometry.maxInstancedCount = numNodes;\n      this.uniforms = {\n        bufferOpacity: {\n          type: 'f',\n          // a float\n          value: _data_config__WEBPACK_IMPORTED_MODULE_3__[\"default\"].nodes.opacity\n        },\n        bufferNodeScale: {\n          type: 'f',\n          value: _data_config__WEBPACK_IMPORTED_MODULE_3__[\"default\"].nodes.scale\n        }\n      };\n      var bufferColors = nodesData.color.flat(); // if the array its is already flatenedk\n\n      var bufferNodePositions = nodesData.pos;\n      var bufferRadius = []; //const f = (arr, index) => arr.push(...[0, 1, 2].map((i)=>nodesData.pos[index*3+i]))\n\n      for (var iNode = 0; iNode < numNodes; iNode++) {\n        //let color = new THREE.Color(nodesData.color[iNode])\n        //bufferColors.push(color.r, color.g, color.b)\n        //bufferColors.push(color.r, color.g, color.b)\n        //bufferNodePositions.push(\n        //nodesData.pos[iNode][0],\n        //nodesData.pos[iNode][1],\n        //nodesData.pos[iNode][2],\n        //)\n        bufferRadius.push(1);\n      } // false that its the bufferCollors will not be normalized, each value\n      // will go from 0 to 255=\n      //\n\n\n      instancedGeometry.addAttribute(\"bufferRadius\", new three__WEBPACK_IMPORTED_MODULE_0__[\"InstancedBufferAttribute\"](new Float32Array(bufferRadius), 1, false));\n      instancedGeometry.addAttribute(\"bufferColors\", new three__WEBPACK_IMPORTED_MODULE_0__[\"InstancedBufferAttribute\"](new Float32Array(bufferColors), 3, false));\n      instancedGeometry.addAttribute(\"bufferNodePositions\", new three__WEBPACK_IMPORTED_MODULE_0__[\"InstancedBufferAttribute\"](new Float32Array(bufferNodePositions), 3, false));\n      var material = new three__WEBPACK_IMPORTED_MODULE_0__[\"ShaderMaterial\"]({\n        fragmentShader: _shaders__WEBPACK_IMPORTED_MODULE_4__[\"fragmentShader\"],\n        vertexShader: _shaders__WEBPACK_IMPORTED_MODULE_4__[\"vertexShader\"],\n        transparent: true,\n        blending: three__WEBPACK_IMPORTED_MODULE_0__[\"NormalBlending\"],\n        uniforms: this.uniforms\n      });\n      var mesh = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](instancedGeometry, material);\n      this.instancedNodes = mesh;\n      this.scene.add(mesh);\n    }\n  }]);\n\n  return Nodes;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/graph/components/nodes/main.js?");

/***/ }),

/***/ "./src/js/graph/components/nodes/shaders.js":
/*!**************************************************!*\
  !*** ./src/js/graph/components/nodes/shaders.js ***!
  \**************************************************/
/*! exports provided: fragmentShaderFixedColor, fragmentShader, vertexShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fragmentShaderFixedColor\", function() { return fragmentShaderFixedColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fragmentShader\", function() { return fragmentShader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vertexShader\", function() { return vertexShader; });\nfunction fragmentShaderFixedColor(c) {\n  var fragmentShader = \"\\n        varying vec3 vColor;\\n        varying float vOpacity;\\n\\n        void main(){\\n            vec3 color = vec3(\".concat(c.r, \", \").concat(c.g, \",\").concat(c.b, \");\\n            float opacity = vOpacity;\\n            gl_FragColor = vec4(color, opacity);\\n\\n        }\\n\\n        \");\n  return fragmentShader;\n}\nvar fragmentShader = \"\\n\\nvarying vec3 vColor;\\nvarying float vOpacity;\\n\\nvoid main(){\\n    vec3 color = vColor;\\n    float opacity = vOpacity;\\n    gl_FragColor = vec4(color, opacity);\\n\\n}\\n\\n\";\nvar vertexShader = \"\\nattribute float bufferRadius;\\nattribute vec3 bufferNodePositions;\\nattribute vec3 bufferColors;\\nuniform float bufferOpacity;\\nuniform float bufferNodeScale;\\nvarying vec3 vColor;\\nvarying float vOpacity;\\n\\nvoid main(){\\n\\n    vec3 pos = vec3(0.);\\n    pos = position + bufferNodePositions;\\n    pos *= bufferRadius;\\n    pos *= bufferNodeScale;\\n\\n    gl_Position = projectionMatrix* modelViewMatrix * vec4(pos, 1.);\\n\\n    vColor = bufferColors;\\n    vOpacity = bufferOpacity;\\n}\\n\\n\";\n\n//# sourceURL=webpack:///./src/js/graph/components/nodes/shaders.js?");

/***/ }),

/***/ "./src/js/graph/components/renderer/main.js":
/*!**************************************************!*\
  !*** ./src/js/graph/components/renderer/main.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Renderer; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var alertifyjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! alertifyjs */ \"./node_modules/alertifyjs/build/alertify.js\");\n/* harmony import */ var alertifyjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(alertifyjs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../data/config */ \"./src/js/data/config.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\nvar Renderer = /*#__PURE__*/function () {\n  function Renderer(scene, canvas, camera, appState) {\n    var _this = this;\n\n    _classCallCheck(this, Renderer);\n\n    this.scene = scene;\n    this.canvas = canvas;\n    this.camera = camera;\n    this.appState = appState; //renderer.toneMapping = THREE.ReinhardToneMapping;\n    // Create WebGL render\n\n    this.renderer = new three__WEBPACK_IMPORTED_MODULE_0__[\"WebGLRenderer\"]({\n      canvas: canvas,\n      antialias: _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].render.antialias,\n      preserveDrawingBuffer: true,\n      alpha: true\n    });\n    this.renderer.setPixelRatio(window.devicePixelRatio); // For retina\n    //this.renderer.shadowMap.enabled = false;\n    //this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n    // Get anisotropy for textures\n\n    _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].maxAnisotropy = this.renderer.getMaxAnisotropy(); // Initial size update set to canvas canvas\n\n    this.updateSize(); // Listeners\n\n    document.addEventListener('DOMContentLoaded', function () {\n      return _this.updateSize();\n    }, false);\n    window.addEventListener('resize', function () {\n      return _this.updateSize();\n    }, false);\n    this.render = this.render.bind(this);\n    this.updateSize = this.updateSize.bind(this);\n    this.takeScreenshot = this.takeScreenshot.bind(this);\n    var btnSave = document.getElementById(\"btnSaveImage\");\n    if (btnSave) btnSave.addEventListener(\"click\", function (event) {\n      return _this.takeScreenshot();\n    });\n  }\n\n  _createClass(Renderer, [{\n    key: \"setCameraAspect\",\n    value: function setCameraAspect(widthRender, heightRender) {\n      var canvas = this.canvas; //const widthRender = window.innerWidth\n      //const heightRender = window.innerHeight\n\n      var aspect = widthRender / heightRender;\n      var change = this.appState.originalAspect / aspect;\n      var newSize = 1 * change;\n      this.camera.left = -aspect * newSize / 2;\n      this.camera.right = aspect * newSize / 2;\n      this.camera.top = newSize / 2;\n      this.camera.bottom = -newSize / 2;\n      this.camera.aspect = widthRender / heightRender;\n      this.camera.updateProjectionMatrix();\n    }\n  }, {\n    key: \"updateSize\",\n    value: function updateSize(widthRender, heightRender) {\n      if (widthRender) widthRender = this.canvas.clientWidth;\n      if (heightRender) heightRender = this.canvas.clientHeight; //if (this.appState.takingScreenshot) return;\n\n      this.setCameraAspect(widthRender, heightRender);\n      this.renderer.setSize(widthRender, heightRender); //this.appState.originalAspect  = aspect\n\n      this.render(); //const pixelRatio = window.devicePixelRatio;\n      //const width  = widthRender  * pixelRatio | 0;\n      //const height = heightRender * pixelRatio | 0;\n      //const needResize = canvas.width !== width || canvas.height !== height;\n      //if (needResize) {\n      //this.renderer.setSize(width, height, );\n      //this.camera.aspect = widthRender / heightRender;\n      //this.camera.updateProjectionMatrix();\n      //}\n      //this.camera.aspect = window.innerWidth / window.innerHeight;\n      //this.camera.updateProjectionMatrix();\n      //this.renderer.setSize( window.innerWidth, window.innerHeight );\n      //this.camera.aspect = this.canvas.clientWidth / this.canvas.clientHeight;\n      //this.camera.updateProjectionMatrix();\n      //if (resizeRendererToDisplaySize(renderer)) {\n      //this.camera.aspect = this.canvas.clientWidth / this.canvas.clientHeight;\n      //this. camera.updateProjectionMatrix();\n      ////}\n      //this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      // Renders scene to canvas target\n      // this.pickHelper.pick( scene, camera, 0)\n      this.renderer.render(this.scene, this.camera);\n    }\n  }, {\n    key: \"takeScreenshot\",\n    value: function takeScreenshot() {\n      $('#saveImageModal').modal(\"hide\");\n      this.appState.takingScreenshot = true;\n      this.appState.stopChanges = true;\n      var widthImage = parseInt(document.getElementById(\"widthSaveImage\").value);\n      var heightImage = parseInt(document.getElementById(\"heightSaveImage\").value);\n      var saveWithTransparency = document.getElementById(\"saveWithTransparency\").checked;\n\n      function dataURIToBlob(dataURI) {\n        var binStr = window.atob(dataURI.split(',')[1]);\n        var len = binStr.length;\n        var arr = new Uint8Array(len);\n\n        for (var i = 0; i < len; i++) {\n          arr[i] = binStr.charCodeAt(i);\n        }\n\n        return new window.Blob([arr]);\n      }\n\n      function saveDataURI(name, dataURI) {\n        var blob = dataURIToBlob(dataURI); // force download\n\n        var link = document.createElement('a');\n        link.download = name;\n        link.href = window.URL.createObjectURL(blob);\n\n        link.onclick = function () {\n          window.setTimeout(function () {\n            window.URL.revokeObjectURL(blob);\n            link.removeAttribute('href');\n          }, 500);\n        };\n\n        link.click();\n      }\n\n      function defaultFileName(ext) {\n        var str = \"\".concat(new Date().toLocaleDateString(), \" at \").concat(new Date().toLocaleTimeString()).concat(ext);\n        return str.replace(/\\//g, '-').replace(/:/g, '.');\n      }\n\n      this.setCameraAspect(widthImage, heightImage); // set camera and renderer to desired screenshot dimension\n      //this.camera.aspect = widthImage / heightImage;\n      //this.camera.updateProjectionMatrix();\n\n      var color = this.scene.background;\n\n      if (saveWithTransparency) {\n        this.renderer.setClearColor(0x000000, 0);\n        this.scene.background = null;\n      }\n\n      this.renderer.setSize(widthImage, heightImage);\n      this.renderer.render(this.scene, this.camera, null, false);\n      var DataURI = this.canvas.toDataURL('image/png', 1.0); // save\n\n      saveDataURI(defaultFileName('.png'), DataURI);\n      if (saveWithTransparency) this.scene.background = color;\n      this.appState.takingScreenshot = false;\n      this.updateSize();\n    }\n  }]);\n\n  return Renderer;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/graph/components/renderer/main.js?");

/***/ }),

/***/ "./src/js/graph/interactions/datGUI.js":
/*!*********************************************!*\
  !*** ./src/js/graph/interactions/datGUI.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DatGUI; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var dat_gui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dat.gui */ \"./node_modules/dat.gui/build/dat.gui.module.js\");\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n //import Config from '../../data/config';\n\nfunction updateDropdown(target, list) {\n  var innerHTMLStr = \"\";\n\n  for (var i = 0; i < list.length; i++) {\n    var str = \"<option value='\" + list[i] + \"'>\" + list[i] + \"</option>\";\n    innerHTMLStr += str;\n  }\n\n  if (innerHTMLStr != \"\") target.domElement.children[0].innerHTML = innerHTMLStr;\n} // Manages all dat.GUI interactions\n\n\nvar DatGUI = /*#__PURE__*/function () {\n  function DatGUI(scene, renderer, camera, nodes0, edges0, Config, appState) {\n    _classCallCheck(this, DatGUI);\n\n    var gui = new dat_gui__WEBPACK_IMPORTED_MODULE_1__[\"GUI\"]();\n    this.gui = gui; //this.camera = main.camera.threeCamera;\n    //this.controls = main.controls.threeControls;\n    //this.light = main.light;\n\n    /* Scene */\n\n    var sceneFolder = gui.addFolder('Scene'); //sceneFolder.addColor(Config.scene, \"color\").name('Color').onChange((color) => {\n    //scene.background = new THREE.Color(color)\n    //render()\n    //});\n\n    /* Nodes */\n\n    var nodesFolder = gui.addFolder('Nodes');\n    nodesFolder.add(Config.nodes, 'show').onChange(function (value) {\n      for (var _i = 0, _Object$entries = Object.entries(nodes0.nodes); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n            nodeName = _Object$entries$_i[0],\n            node = _Object$entries$_i[1];\n\n        node.visible = value;\n      }\n\n      Config.nodes.show = value;\n      render();\n    });\n    var nodesGuiRadius = nodesFolder.add(Config.nodes, 'radius', 0, 3).name('Radius');\n    nodesFolder.addColor(Config.nodes, \"color\").name('Color').onChange(function (color) {\n      nodes0.changeColor(color);\n      render();\n    });\n    nodesFolder.add(Config.nodes, 'scale', 0.01, 5).name('Scale').onChange(function (value) {\n      nodes0.changeScale(value); //node.material.opacity=value;\n    });\n    nodesFolder.add(Config.nodes, 'opacity', 0, 1).name('Opacity').onChange(function (value) {\n      nodes0.changeOpacity(value); //node.material.opacity=value;\n    });\n    this.colorProp = nodesFolder.add(appState, \"defaultProps\", appState.defaultProps).name(\"Color by Prop.\").onChange(function (value) {\n      nodes0.colorByProp(value);\n    });\n    this.colorField = nodesFolder.add(appState, \"defaultProps\", appState.defaultProps).name(\"Color by Field.\").onChange(function (value) {\n      nodes0.colorByField(value);\n    });\n    nodesFolder.open();\n    this.nodesFolder = nodesFolder;\n    /* Edges */\n\n    var edgesFolder = gui.addFolder('Edges');\n    edgesFolder.add(Config.edges, 'show').onChange(function (value) {\n      Config.edges.show = value;\n      render();\n    }); //edgesFolder.addColor(Config.edges, \"color\").name('Color')\n    //.onChange((color) => {\n    //edges0.changeColor(color)\n    //});\n\n    var colorEdge = {\n      prop: [],\n      field: []\n    };\n    this.colorEdgeProp = edgesFolder.add(colorEdge, \"prop\", colorEdge.prop).name(\"Color by Prop.\").onChange(function (value) {\n      edges0.colorByProp(value);\n    });\n    this.colorEdgeField = edgesFolder.add(colorEdge, \"field\", colorEdge.prop).name(\"Color by Field.\").onChange(function (value) {\n      edges0.colorByField(value);\n    }); //nodesFolder.add(Config.nodes, 'scale', 0.01, 5).name('Scale').onChange((value) => {\n    //nodes0.changeScale(value)\n    ////node.material.opacity=value;\n    //});\n\n    edgesFolder.add(Config.edges, 'opacity', 0, 1).name('Opacity').onChange(function (value) {\n      edges0.changeOpacity(value); //node.material.opacity=value;\n    }); //Edges Bloom\n    //edgesFolder.addColor(Config.layers[edgesBloomScene], 'clearColor' ).onChange( function ( color ) {\n    //bloomPassEdges.clearColor.set(color)\n    //render()\n    //});\n    //edgesFolder.add( Config.layers[edgesBloomScene], 'enabled' ).onChange( function ( value ) {\n    //bloomPassEdges.enabled = value\n    //render();\n    //} );\n    //edgesFolder.add( Config.layers[edgesBloomScene], 'strength', 0.0, 2 ).onChange( function ( value ) {\n    ////bloomPassEdges.copyUniforms.opacity(value)\n    //bloomPassEdges.strength = value\n    //render();\n    //} );\n    //edgesFolder.add( Config.layers[edgesBloomScene], 'exposure', 0.01, 2 ).onChange( function ( value ) {\n    //renderer.toneMappingExposure = Math.pow( value, 1.0 );\n    //render();\n    //} );\n    //edgesFolder.add( Config.layers[edgesBloomScene], 'bloomThreshold', 0.0, 10 ).step(0.01).onChange( function ( value ) {\n    //bloomPassEdges.threshold = Number( value )/100;\n    //render();\n    //} );\n    //edgesFolder.add( Config.layers[edgesBloomScene], 'bloomStrength', 0.0, 2.0 ).onChange( function ( value ) {\n    //bloomPassEdges.strength = Number( value );\n    //render();\n    //} );\n    //edgesFolder.add( Config.layers[edgesBloomScene], 'bloomRadius', 0.0, 1.0 ).step( 0.01 ).onChange( function ( value ) {\n    //bloomPassEdges.radius = Number( value );\n    //render();\n    //} );\n\n    edgesFolder.open();\n    /* Controls */\n    //const controlsFolder = gui.addFolder('Controls');\n    //controlsFolder.add(Config.controls, 'autoRotate').name('Auto Rotate').onChange((value) => {\n    //this.controls.autoRotate = value;\n    //});\n    //const controlsAutoRotateSpeedGui = controlsFolder.add(Config.controls, 'autoRotateSpeed', -1, 1).name('Rotation Speed');\n    //controlsAutoRotateSpeedGui.onChange((value) => {\n    //this.controls.enableRotate = false;\n    //this.controls.autoRotateSpeed = value;\n    //});\n    //controlsAutoRotateSpeedGui.onFinishChange(() => {\n    //this.controls.enableRotate = true;\n    //});\n\n    /* Mesh */\n  }\n\n  _createClass(DatGUI, [{\n    key: \"updateNodeColorProp\",\n    value: function updateNodeColorProp(values) {\n      updateDropdown(this.colorField, values);\n      updateDropdown(this.colorProp, values);\n    }\n  }, {\n    key: \"updateEdgeColorProp\",\n    value: function updateEdgeColorProp(values) {\n      updateDropdown(this.colorEdgeField, values);\n      updateDropdown(this.colorEdgeProp, values);\n    }\n  }]);\n\n  return DatGUI;\n}(); //unreal bloom effect\n//enabled: true\n//needsSwap: false\n//clear: false\n//renderToScreen: true\n//strength: 5\n//radius: 0\n//threshold: 0\n//resolution: Vector2 {x: 1366, y: 348}\n//clearColor: Color\n//r: 255\n//g: 255\n//b: 255\n//__proto__: Object\n//renderTargetsHorizontal: (5) [WebGLRenderTarget, WebGLRenderTarget, WebGLRenderTarget, WebGLRenderTarget, WebGLRenderTarget]\n//renderTargetsVertical: (5) [WebGLRenderTarget, WebGLRenderTarget, WebGLRenderTarget, WebGLRenderTarget, WebGLRenderTarget]\n//nMips: 5\n//renderTargetBright: WebGLRenderTarget {width: 683, height: 174, scissor: Vector4, scissorTest: false, viewport: Vector4, }\n//highPassUniforms: {tDiffuse: {}, luminosityThreshold: {}, smoothWidth: {}, defaultColor: {}, defaultOpacity: {}}\n//materialHighPassFilter: ShaderMaterial {uuid: \"031D54E9-22F3-4F42-8C31-EF4D970724C3\", name: \"\", type: \"ShaderMaterial\", fog: false, blending: 1, }\n//separableBlurMaterials: (5) [ShaderMaterial, ShaderMaterial, ShaderMaterial, ShaderMaterial, ShaderMaterial]\n//compositeMaterial: ShaderMaterial {uuid: \"DBA670AF-AC33-428C-BAB3-91BE67FE2901\", name: \"\", type: \"ShaderMaterial\", fog: false, blending: 1, }\n//bloomTintColors: (5) [Vector3, Vector3, Vector3, Vector3, Vector3]\n//copyUniforms: {tDiffuse: {}, opacity: {}}\n//materialCopy: ShaderMaterial {uuid: \"369D3C24-A73E-4576-BB78-E1261A5E6D64\", name: \"\", type: \"ShaderMaterial\", fog: false, blending: 2, }\n//oldClearColor: Color {}\n//oldClearAlpha: 1\n\n\n\n\n//# sourceURL=webpack:///./src/js/graph/interactions/datGUI.js?");

/***/ }),

/***/ "./src/js/graph/interactions/keyboard.js":
/*!***********************************************!*\
  !*** ./src/js/graph/interactions/keyboard.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Interaction; });\n/* harmony import */ var _utils_keyboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/keyboard */ \"./src/js/utils/keyboard.js\");\n/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/helpers */ \"./src/js/utils/helpers.js\");\n/* harmony import */ var alertifyjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! alertifyjs */ \"./node_modules/alertifyjs/build/alertify.js\");\n/* harmony import */ var alertifyjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(alertifyjs__WEBPACK_IMPORTED_MODULE_2__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n //import Config from \"../../data/config\";\n\n // Manages all input interactions\n\nvar Interaction = /*#__PURE__*/function () {\n  function Interaction(canvas, appState, Config, datGui, keypressFunc) {\n    var _this = this;\n\n    _classCallCheck(this, Interaction);\n\n    // Properties\n    this.canvas = canvas;\n    this.keypressFunc = keypressFunc;\n    this.datGui = datGui;\n    this.timeout = null; // Instantiate keyboard helper\n\n    this.keyboard = new _utils_keyboard__WEBPACK_IMPORTED_MODULE_0__[\"default\"](); // Listeners\n    // Mouse events\n\n    this.keypressEvent = this.keypressEvent.bind(this); // Keyboard events\n\n    this.keyboard.domElement.addEventListener(\"keydown\", function (event) {\n      return _this.keypressEvent(event);\n    } // Only once\n    //if(this.keyboard.eventMatches(event, 'escape')) {\n    //  console.log('Escape pressed');\n    // }\n    );\n    this.appState = appState;\n  }\n\n  _createClass(Interaction, [{\n    key: \"keypressEvent\",\n    value: function keypressEvent(event) {\n      var _this2 = this;\n\n      var repeat = event.repeat;\n      var key = event.key;\n      var alertHTMLobj = document.getElementById(\"bootstraAlertStrong\"); //let bootstrapAlert = document.getElementById(\"bootstrapAlert\")\n\n      var bootstrapAlert = $(\"#bootstrapAlert\");\n\n      switch (key.toLowerCase()) {\n        case \"e\":\n          alertifyjs__WEBPACK_IMPORTED_MODULE_2___default.a.message(\"Edition Mode\");\n          this.datGui.closed = true;\n          this.appState.vimMode = \"Edition\";\n          console.info(\"Vim mode Edition\");\n          break;\n\n        case \"v\":\n          alertifyjs__WEBPACK_IMPORTED_MODULE_2___default.a.message(\"Visual Mode\");\n          this.datGui.closed = false;\n          this.appState.vimMode = \"Visual\";\n          console.info(\"Vim mode Visualization\");\n          break;\n\n        case \"n\":\n          alertifyjs__WEBPACK_IMPORTED_MODULE_2___default.a.message(\"Navigation Mode\");\n          this.datGui.closed = true;\n          this.appState.vimMode = \"Navigation\";\n          break;\n\n        case \"s\":\n          document.getElementById(\"widthSaveImage\").value = window.innerWidth;\n          document.getElementById(\"heightSaveImage\").value = window.innerHeight;\n          $('#saveImageModal').modal(\"show\");\n\n        case \"d\":\n          if (this.appState.vimMode == \"Edition\") this.keypressFunc(key, \"deleteNode\");\n          break;\n\n        case \"l\":\n        case \"j\":\n        case \"i\":\n        case \"k\":\n          if (this.appState.vimMode == \"Visual\" && key == \"l\") {\n            alertifyjs__WEBPACK_IMPORTED_MODULE_2___default.a.confirm(\"Are you sure you want to reload the graph?\", function () {\n              _this2.keypressFunc(key, \"reloadGraph\");\n            });\n          }\n\n          if (this.appState.vimMode == \"Edition\") {\n            this.keypressFunc(key, \"move\");\n            repeat = false;\n          }\n\n          break;\n\n        case \"r\":\n          if (this.appState.vimMode == \"Visual\") alertifyjs__WEBPACK_IMPORTED_MODULE_2___default.a.message(\"Recalculating  positions\");\n          this.keypressFunc(key, \"recalcPos\");\n          break;\n\n        default:\n          break;\n      }\n\n      if (repeat) {\n        return;\n      } //console.log(\"keydown\", event);\n\n    }\n  }]);\n\n  return Interaction;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/graph/interactions/keyboard.js?");

/***/ }),

/***/ "./src/js/graph/main.js":
/*!******************************!*\
  !*** ./src/js/graph/main.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Graph; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var alertifyjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! alertifyjs */ \"./node_modules/alertifyjs/build/alertify.js\");\n/* harmony import */ var alertifyjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(alertifyjs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_renderer_main__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/renderer/main */ \"./src/js/graph/components/renderer/main.js\");\n/* harmony import */ var _components_controls__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/controls */ \"./src/js/graph/components/controls.js\");\n/* harmony import */ var _components_nodes_main__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/nodes/main */ \"./src/js/graph/components/nodes/main.js\");\n/* harmony import */ var _components_edges_main__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/edges/main */ \"./src/js/graph/components/edges/main.js\");\n/* harmony import */ var _interactions_keyboard__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./interactions/keyboard */ \"./src/js/graph/interactions/keyboard.js\");\n/* harmony import */ var _interactions_datGUI__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./interactions/datGUI */ \"./src/js/graph/interactions/datGUI.js\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Global imports -\n\n // Components\n\n //import PickCamera from \"./components/pick\";\n\n\n\n // User Interaction\n\n\n // data\n//import Config from \"./../data/config\";\n// State of the application\n\nvar Graph = /*#__PURE__*/function () {\n  function Graph(idCanvasHTML, Config, keyboardPressFunction) {\n    _classCallCheck(this, Graph);\n\n    this.Config = Config;\n    this.canvas = document.querySelector(\"#appContainer\");\n    this.camera = new three__WEBPACK_IMPORTED_MODULE_0__[\"PerspectiveCamera\"](Config.camera.fov, Config.camera.aspect, Config.camera.near, Config.camera.far);\n    this.scene = new three__WEBPACK_IMPORTED_MODULE_0__[\"Scene\"]();\n    this.renderer;\n    this.state;\n    this.keyboardPressFunction = keyboardPressFunction; //this.init = this.init.bind(this)\n  }\n\n  _createClass(Graph, [{\n    key: \"init\",\n    value: function init() {\n      this.state = _defineProperty({\n        vimMode: \"Visual\",\n        isLoaded: false,\n        firstLoad: true,\n        takingScreenshot: false,\n        defaultProps: {},\n        stopChanges: false,\n        renders: [],\n        rendering: false\n      }, \"defaultProps\", {});\n      var viewSize = 1;\n      var aspectRatio = window.innerWidth / window.innerHeight;\n      this.state.originalAspect = window.innerWidth / window.innerHeight;\n      this.scene.add(this.camera);\n      this.scene.background = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](this.Config.scene.color);\n      this.nodes = new _components_nodes_main__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.scene, 0, 0);\n      this.edges = new _components_edges_main__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this.scene, 0, 1);\n      this.renderer = new _components_renderer_main__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.scene, this.canvas, this.camera, this.state);\n      this.controls = new _components_controls__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.camera, this.canvas, this.renderer.render);\n      this.datGui = new _interactions_datGUI__WEBPACK_IMPORTED_MODULE_7__[\"default\"](this.scene, this.renderer, this.camera, this.nodes, this.edges, this.Config, //bloomPassEdges,edgesBloomScene,\n      this.state);\n      this.keyboardInteraction = new _interactions_keyboard__WEBPACK_IMPORTED_MODULE_6__[\"default\"](this.canvas, this.state, this.Config, this.datGui.gui, this.keyboardPressFunction);\n    }\n  }, {\n    key: \"ressetLook\",\n    value: function ressetLook() {\n      var position = this.edges.instancedEdges.geometry.boundingSphere.center;\n      this.camera.position.z = 4 * this.edges.instancedEdges.geometry.boundingSphere.radius;\n      this.camera.lookAt(position);\n      this.camera.updateProjectionMatrix();\n      this.renderer.render();\n    }\n  }]);\n\n  return Graph;\n}(); //{\n//const color = 0xffffff;\n//const intensity = 4;\n//const light = new THREE.DirectionalLight(color, intensity);\n//light.position.set(-1, 2, 4);\n//light.layers.enable(0)\n//camera.add(light);\n//}\n\n\n\n\n//# sourceURL=webpack:///./src/js/graph/main.js?");

/***/ }),

/***/ "./src/js/utils/helpers.js":
/*!*********************************!*\
  !*** ./src/js/utils/helpers.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Helpers; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Provides simple static functions that are used multiple times in the app\nvar Helpers = /*#__PURE__*/function () {\n  function Helpers() {\n    _classCallCheck(this, Helpers);\n  }\n\n  _createClass(Helpers, null, [{\n    key: \"throttle\",\n    value: function throttle(fn, threshhold, scope) {\n      threshhold || (threshhold = 250);\n      var last, deferTimer;\n      return function () {\n        var context = scope || this;\n        var now = +new Date(),\n            args = arguments;\n\n        if (last && now < last + threshhold) {\n          clearTimeout(deferTimer);\n          deferTimer = setTimeout(function () {\n            last = now;\n            fn.apply(context, args);\n          }, threshhold);\n        } else {\n          last = now;\n          fn.apply(context, args);\n        }\n      };\n    }\n  }, {\n    key: \"logProgress\",\n    value: function logProgress() {\n      return function (xhr) {\n        if (xhr.lengthComputable) {\n          var percentComplete = xhr.loaded / xhr.total * 100;\n          console.log(Math.round(percentComplete, 2) + '% downloaded');\n        }\n      };\n    }\n  }, {\n    key: \"logError\",\n    value: function logError() {\n      return function (xhr) {\n        console.error(xhr);\n      };\n    }\n  }, {\n    key: \"handleColorChange\",\n    value: function handleColorChange(color) {\n      return function (value) {\n        if (typeof value === 'string') {\n          value = value.replace('#', '0x');\n        }\n\n        color.setHex(value);\n      };\n    }\n  }, {\n    key: \"update\",\n    value: function update(mesh) {\n      this.needsUpdate(mesh.material, mesh.geometry);\n    }\n  }, {\n    key: \"needsUpdate\",\n    value: function needsUpdate(material, geometry) {\n      return function () {\n        material.shading = +material.shading; //Ensure number\n\n        material.vertexColors = +material.vertexColors; //Ensure number\n\n        material.side = +material.side; //Ensure number\n\n        material.needsUpdate = true;\n        geometry.verticesNeedUpdate = true;\n        geometry.normalsNeedUpdate = true;\n        geometry.colorsNeedUpdate = true;\n      };\n    }\n  }, {\n    key: \"updateTexture\",\n    value: function updateTexture(material, materialKey, textures) {\n      return function (key) {\n        material[materialKey] = textures[key];\n        material.needsUpdate = true;\n      };\n    }\n  }]);\n\n  return Helpers;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/utils/helpers.js?");

/***/ }),

/***/ "./src/js/utils/keyboard.js":
/*!**********************************!*\
  !*** ./src/js/utils/keyboard.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Keyboard; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar ALIAS = {\n  'left': 37,\n  'up': 38,\n  'right': 39,\n  'down': 40,\n  'space': 32,\n  'tab': 9,\n  'escape': 27\n};\n\nvar Keyboard = /*#__PURE__*/function () {\n  function Keyboard(domElement) {\n    var _this = this;\n\n    _classCallCheck(this, Keyboard);\n\n    this.domElement = domElement || document;\n    this.keyCodes = {}; // bind keyEvents\n\n    this.domElement.addEventListener('keydown', function (event) {\n      return _this.onKeyChange(event);\n    }, false);\n    this.domElement.addEventListener('keyup', function (event) {\n      return _this.onKeyChange(event);\n    }, false); // bind window blur\n\n    window.addEventListener('blur', function () {\n      return _this.onBlur;\n    }, false);\n  }\n\n  _createClass(Keyboard, [{\n    key: \"destroy\",\n    value: function destroy() {\n      var _this2 = this;\n\n      this.domElement.removeEventListener('keydown', function (event) {\n        return _this2.onKeyChange(event);\n      }, false);\n      this.domElement.removeEventListener('keyup', function (event) {\n        return _this2.onKeyChange(event);\n      }, false); // unbind window blur event\n\n      window.removeEventListener('blur', function () {\n        return _this2.onBlur;\n      }, false);\n    }\n  }, {\n    key: \"onBlur\",\n    value: function onBlur() {\n      for (var prop in this.keyCodes) {\n        this.keyCodes[prop] = false;\n      }\n    }\n  }, {\n    key: \"onKeyChange\",\n    value: function onKeyChange(event) {\n      // log to debug\n      //console.log('onKeyChange', event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey)\n      // update this.keyCodes\n      var keyCode = event.keyCode;\n      this.keyCodes[keyCode] = event.type === 'keydown';\n    }\n  }, {\n    key: \"pressed\",\n    value: function pressed(keyDesc) {\n      var keys = keyDesc.split('+');\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var pressed = false;\n\n        if (Object.keys(ALIAS).indexOf(key) != -1) {\n          pressed = this.keyCodes[ALIAS[key]];\n        } else {\n          pressed = this.keyCodes[key.toUpperCase().charCodeAt(0)];\n        }\n\n        if (!pressed) return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"eventMatches\",\n    value: function eventMatches(event, keyDesc) {\n      var aliases = ALIAS;\n      var aliasKeys = Object.keys(aliases);\n      var keys = keyDesc.split('+'); // log to debug\n      // console.log('eventMatches', event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey)\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var pressed = false;\n\n        if (key === 'shift') {\n          pressed = event.shiftKey ? true : false;\n        } else if (key === 'ctrl') {\n          pressed = event.ctrlKey ? true : false;\n        } else if (key === 'alt') {\n          pressed = event.altKey ? true : false;\n        } else if (key === 'meta') {\n          pressed = event.metaKey ? true : false;\n        } else if (aliasKeys.indexOf(key) !== -1) {\n          pressed = event.keyCode === aliases[key];\n        } else if (event.keyCode === key.toUpperCase().charCodeAt(0)) {\n          pressed = true;\n        }\n\n        if (!pressed) return false;\n      }\n\n      return true;\n    }\n  }]);\n\n  return Keyboard;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/utils/keyboard.js?");

/***/ }),

/***/ "./src/js/utils/orbitControls.js":
/*!***************************************!*\
  !*** ./src/js/utils/orbitControls.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (THREE) {\n  var MOUSE = THREE.MOUSE;\n  if (!MOUSE) MOUSE = {\n    LEFT: 0,\n    MIDDLE: 1,\n    RIGHT: 2\n  };\n  /**\n   * @author qiao / https://github.com/qiao\n   * @author mrdoob / http://mrdoob.com\n   * @author alteredq / http://alteredqualia.com/\n   * @author WestLangley / http://github.com/WestLangley\n   * @author erich666 / http://erichaines.com\n   */\n\n  /*global THREE, console */\n\n  function OrbitConstraint(object) {\n    this.object = object; // \"target\" sets the location of focus, where the object orbits around\n    // and where it pans with respect to.\n\n    this.target = new THREE.Vector3(); // Limits to how far you can dolly in and out ( PerspectiveCamera only )\n\n    this.minDistance = 0;\n    this.maxDistance = Infinity; // Limits to how far you can zoom in and out ( OrthographicCamera only )\n\n    this.minZoom = 0;\n    this.maxZoom = Infinity; // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n\n    this.minPolarAngle = 0; // radians\n\n    this.maxPolarAngle = Math.PI; // radians\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\n    this.minAzimuthAngle = -Infinity; // radians\n\n    this.maxAzimuthAngle = Infinity; // radians\n    // Set to true to enable damping (inertia)\n    // If damping is enabled, you must call controls.update() in your animation loop\n\n    this.enableDamping = false;\n    this.dampingFactor = 0.25; ////////////\n    // internals\n\n    var scope = this;\n    var EPS = 0.000001; // Current position in spherical coordinate system.\n\n    var theta;\n    var phi; // Pending changes\n\n    var phiDelta = 0;\n    var thetaDelta = 0;\n    var scale = 1;\n    var panOffset = new THREE.Vector3();\n    var zoomChanged = false; // API\n\n    this.getPolarAngle = function () {\n      return phi;\n    };\n\n    this.getAzimuthalAngle = function () {\n      return theta;\n    };\n\n    this.rotateLeft = function (angle) {\n      thetaDelta -= angle;\n    };\n\n    this.rotateUp = function (angle) {\n      phiDelta -= angle;\n    }; // pass in distance in world space to move left\n\n\n    this.panLeft = function () {\n      var v = new THREE.Vector3();\n      return function panLeft(distance) {\n        var te = this.object.matrix.elements; // get X column of matrix\n\n        v.set(te[0], te[1], te[2]);\n        v.multiplyScalar(-distance);\n        panOffset.add(v);\n      };\n    }(); // pass in distance in world space to move up\n\n\n    this.panUp = function () {\n      var v = new THREE.Vector3();\n      return function panUp(distance) {\n        var te = this.object.matrix.elements; // get Y column of matrix\n\n        v.set(te[4], te[5], te[6]);\n        v.multiplyScalar(distance);\n        panOffset.add(v);\n      };\n    }(); // pass in x,y of change desired in pixel space,\n    // right and down are positive\n\n\n    this.pan = function (deltaX, deltaY, screenWidth, screenHeight) {\n      if (scope.object instanceof THREE.PerspectiveCamera) {\n        // perspective\n        var position = scope.object.position;\n        var offset = position.clone().sub(scope.target);\n        var targetDistance = offset.length(); // half of the fov is center to top of screen\n\n        targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0); // we actually don't use screenWidth, since perspective camera is fixed to screen height\n\n        scope.panLeft(2 * deltaX * targetDistance / screenHeight);\n        scope.panUp(2 * deltaY * targetDistance / screenHeight);\n      } else if (scope.object instanceof THREE.OrthographicCamera) {\n        // orthographic\n        scope.panLeft(deltaX * (scope.object.right - scope.object.left) / screenWidth);\n        scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / screenHeight);\n      } else {\n        // camera neither orthographic or perspective\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n      }\n    };\n\n    this.dollyIn = function (dollyScale) {\n      if (scope.object instanceof THREE.PerspectiveCamera) {\n        scale /= dollyScale;\n      } else if (scope.object instanceof THREE.OrthographicCamera) {\n        scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * dollyScale));\n        scope.object.updateProjectionMatrix();\n        zoomChanged = true;\n      } else {\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n      }\n    };\n\n    this.dollyOut = function (dollyScale) {\n      if (scope.object instanceof THREE.PerspectiveCamera) {\n        scale *= dollyScale;\n      } else if (scope.object instanceof THREE.OrthographicCamera) {\n        scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / dollyScale));\n        scope.object.updateProjectionMatrix();\n        zoomChanged = true;\n      } else {\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n      }\n    };\n\n    this.update = function () {\n      var offset = new THREE.Vector3(); // so camera.up is the orbit axis\n\n      var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n      var quatInverse = quat.clone().inverse();\n      var lastPosition = new THREE.Vector3();\n      var lastQuaternion = new THREE.Quaternion();\n      return function () {\n        var position = this.object.position;\n        offset.copy(position).sub(this.target); // rotate offset to \"y-axis-is-up\" space\n\n        offset.applyQuaternion(quat); // angle from z-axis around y-axis\n\n        theta = Math.atan2(offset.x, offset.z); // angle from y-axis\n\n        phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n        theta += thetaDelta;\n        phi += phiDelta; // restrict theta to be between desired limits\n\n        theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta)); // restrict phi to be between desired limits\n\n        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi)); // restrict phi to be betwee EPS and PI-EPS\n\n        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n        var radius = offset.length() * scale; // restrict radius to be between desired limits\n\n        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius)); // move target to panned location\n\n        this.target.add(panOffset);\n        offset.x = radius * Math.sin(phi) * Math.sin(theta);\n        offset.y = radius * Math.cos(phi);\n        offset.z = radius * Math.sin(phi) * Math.cos(theta); // rotate offset back to \"camera-up-vector-is-up\" space\n\n        offset.applyQuaternion(quatInverse);\n        position.copy(this.target).add(offset);\n        this.object.lookAt(this.target);\n\n        if (this.enableDamping === true) {\n          thetaDelta *= 1 - this.dampingFactor;\n          phiDelta *= 1 - this.dampingFactor;\n        } else {\n          thetaDelta = 0;\n          phiDelta = 0;\n        }\n\n        scale = 1;\n        panOffset.set(0, 0, 0); // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (zoomChanged || lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {\n          lastPosition.copy(this.object.position);\n          lastQuaternion.copy(this.object.quaternion);\n          zoomChanged = false;\n          return true;\n        }\n\n        return false;\n      };\n    }();\n  }\n\n  ; // This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n  // the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n  // supported.\n  //\n  //    Orbit - left mouse / touch: one finger move\n  //    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n  //    Pan - right mouse, or arrow keys / touch: three finter swipe\n\n  function OrbitControls(object, domElement) {\n    var constraint = new OrbitConstraint(object);\n    this.domElement = domElement !== undefined ? domElement : document; // API\n\n    Object.defineProperty(this, 'constraint', {\n      get: function get() {\n        return constraint;\n      }\n    });\n\n    this.getPolarAngle = function () {\n      return constraint.getPolarAngle();\n    };\n\n    this.getAzimuthalAngle = function () {\n      return constraint.getAzimuthalAngle();\n    }; // Set to false to disable this control\n\n\n    this.enabled = true; // center is old, deprecated; use \"target\" instead\n\n    this.center = this.target; // This option actually enables dollying in and out; left as \"zoom\" for\n    // backwards compatibility.\n    // Set to false to disable zooming\n\n    this.enableZoom = true;\n    this.zoomSpeed = 1.0; // Set to false to disable rotating\n\n    this.enableRotate = true;\n    this.rotateSpeed = 1.0; // Set to false to disable panning\n\n    this.enablePan = true;\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n    // Set to true to automatically rotate around the target\n    // If auto-rotate is enabled, you must call controls.update() in your animation loop\n\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n    // Set to false to disable use of the keys\n\n    this.enableKeys = true; // The four arrow keys\n\n    this.keys = {\n      LEFT: 37,\n      UP: 38,\n      RIGHT: 39,\n      BOTTOM: 40\n    }; // Mouse buttons\n\n    this.mouseButtons = {\n      ORBIT: THREE.MOUSE.LEFT,\n      ZOOM: THREE.MOUSE.MIDDLE,\n      PAN: THREE.MOUSE.RIGHT\n    }; ////////////\n    // internals\n\n    var scope = this;\n    var rotateStart = new THREE.Vector2();\n    var rotateEnd = new THREE.Vector2();\n    var rotateDelta = new THREE.Vector2();\n    var panStart = new THREE.Vector2();\n    var panEnd = new THREE.Vector2();\n    var panDelta = new THREE.Vector2();\n    var dollyStart = new THREE.Vector2();\n    var dollyEnd = new THREE.Vector2();\n    var dollyDelta = new THREE.Vector2();\n    var STATE = {\n      NONE: -1,\n      ROTATE: 0,\n      DOLLY: 1,\n      PAN: 2,\n      TOUCH_ROTATE: 3,\n      TOUCH_DOLLY: 4,\n      TOUCH_PAN: 5\n    };\n    var state = STATE.NONE; // for reset\n\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n    this.zoom0 = this.object.zoom; // events\n\n    var changeEvent = {\n      type: 'change'\n    };\n    var startEvent = {\n      type: 'start'\n    };\n    var endEvent = {\n      type: 'end'\n    }; // pass in x,y of change desired in pixel space,\n    // right and down are positive\n\n    function pan(deltaX, deltaY) {\n      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n      constraint.pan(deltaX, deltaY, element.clientWidth, element.clientHeight);\n    }\n\n    this.update = function () {\n      if (this.autoRotate && state === STATE.NONE) {\n        constraint.rotateLeft(getAutoRotationAngle());\n      }\n\n      if (constraint.update() === true) {\n        this.dispatchEvent(changeEvent);\n      }\n    };\n\n    this.reset = function () {\n      state = STATE.NONE;\n      this.target.copy(this.target0);\n      this.object.position.copy(this.position0);\n      this.object.zoom = this.zoom0;\n      this.object.updateProjectionMatrix();\n      this.dispatchEvent(changeEvent);\n      this.update();\n    };\n\n    function getAutoRotationAngle() {\n      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n    }\n\n    function getZoomScale() {\n      return Math.pow(0.95, scope.zoomSpeed);\n    }\n\n    function onMouseDown(event) {\n      if (scope.enabled === false) return;\n      event.preventDefault();\n\n      if (event.button === scope.mouseButtons.ORBIT) {\n        if (scope.enableRotate === false) return;\n        state = STATE.ROTATE;\n        rotateStart.set(event.clientX, event.clientY);\n      } else if (event.button === scope.mouseButtons.ZOOM) {\n        if (scope.enableZoom === false) return;\n        state = STATE.DOLLY;\n        dollyStart.set(event.clientX, event.clientY);\n      } else if (event.button === scope.mouseButtons.PAN) {\n        if (scope.enablePan === false) return;\n        state = STATE.PAN;\n        panStart.set(event.clientX, event.clientY);\n      }\n\n      if (state !== STATE.NONE) {\n        document.addEventListener('mousemove', onMouseMove, false);\n        document.addEventListener('mouseup', onMouseUp, false);\n        scope.dispatchEvent(startEvent);\n      }\n    }\n\n    function onMouseMove(event) {\n      if (scope.enabled === false) return;\n      event.preventDefault();\n      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n      if (state === STATE.ROTATE) {\n        if (scope.enableRotate === false) return;\n        rotateEnd.set(event.clientX, event.clientY);\n        rotateDelta.subVectors(rotateEnd, rotateStart); // rotating across whole screen goes 360 degrees around\n\n        constraint.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed); // rotating up and down along whole screen attempts to go 360, but limited to 180\n\n        constraint.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n        rotateStart.copy(rotateEnd);\n      } else if (state === STATE.DOLLY) {\n        if (scope.enableZoom === false) return;\n        dollyEnd.set(event.clientX, event.clientY);\n        dollyDelta.subVectors(dollyEnd, dollyStart);\n\n        if (dollyDelta.y > 0) {\n          constraint.dollyIn(getZoomScale());\n        } else if (dollyDelta.y < 0) {\n          constraint.dollyOut(getZoomScale());\n        }\n\n        dollyStart.copy(dollyEnd);\n      } else if (state === STATE.PAN) {\n        if (scope.enablePan === false) return;\n        panEnd.set(event.clientX, event.clientY);\n        panDelta.subVectors(panEnd, panStart);\n        pan(panDelta.x, panDelta.y);\n        panStart.copy(panEnd);\n      }\n\n      if (state !== STATE.NONE) scope.update();\n    }\n\n    function onMouseUp()\n    /* event */\n    {\n      if (scope.enabled === false) return;\n      document.removeEventListener('mousemove', onMouseMove, false);\n      document.removeEventListener('mouseup', onMouseUp, false);\n      scope.dispatchEvent(endEvent);\n      state = STATE.NONE;\n    }\n\n    function onMouseWheel(event) {\n      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE) return;\n      event.preventDefault();\n      event.stopPropagation();\n      var delta = 0;\n\n      if (event.wheelDelta !== undefined) {\n        // WebKit / Opera / Explorer 9\n        delta = event.wheelDelta;\n      } else if (event.detail !== undefined) {\n        // Firefox\n        delta = -event.detail;\n      }\n\n      if (delta > 0) {\n        constraint.dollyOut(getZoomScale());\n      } else if (delta < 0) {\n        constraint.dollyIn(getZoomScale());\n      }\n\n      scope.update();\n      scope.dispatchEvent(startEvent);\n      scope.dispatchEvent(endEvent);\n    }\n\n    function onKeyDown(event) {\n      if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;\n\n      switch (event.keyCode) {\n        case scope.keys.UP:\n          pan(0, scope.keyPanSpeed);\n          scope.update();\n          break;\n\n        case scope.keys.BOTTOM:\n          pan(0, -scope.keyPanSpeed);\n          scope.update();\n          break;\n\n        case scope.keys.LEFT:\n          pan(scope.keyPanSpeed, 0);\n          scope.update();\n          break;\n\n        case scope.keys.RIGHT:\n          pan(-scope.keyPanSpeed, 0);\n          scope.update();\n          break;\n      }\n    }\n\n    function touchstart(event) {\n      if (scope.enabled === false) return;\n\n      switch (event.touches.length) {\n        case 1:\n          // one-fingered touch: rotate\n          if (scope.enableRotate === false) return;\n          state = STATE.TOUCH_ROTATE;\n          rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n          break;\n\n        case 2:\n          // two-fingered touch: dolly\n          if (scope.enableZoom === false) return;\n          state = STATE.TOUCH_DOLLY;\n          var dx = event.touches[0].pageX - event.touches[1].pageX;\n          var dy = event.touches[0].pageY - event.touches[1].pageY;\n          var distance = Math.sqrt(dx * dx + dy * dy);\n          dollyStart.set(0, distance);\n          break;\n\n        case 3:\n          // three-fingered touch: pan\n          if (scope.enablePan === false) return;\n          state = STATE.TOUCH_PAN;\n          panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n          break;\n\n        default:\n          state = STATE.NONE;\n      }\n\n      if (state !== STATE.NONE) scope.dispatchEvent(startEvent);\n    }\n\n    function touchmove(event) {\n      if (scope.enabled === false) return;\n      event.preventDefault();\n      event.stopPropagation();\n      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n      switch (event.touches.length) {\n        case 1:\n          // one-fingered touch: rotate\n          if (scope.enableRotate === false) return;\n          if (state !== STATE.TOUCH_ROTATE) return;\n          rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n          rotateDelta.subVectors(rotateEnd, rotateStart); // rotating across whole screen goes 360 degrees around\n\n          constraint.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed); // rotating up and down along whole screen attempts to go 360, but limited to 180\n\n          constraint.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n          rotateStart.copy(rotateEnd);\n          scope.update();\n          break;\n\n        case 2:\n          // two-fingered touch: dolly\n          if (scope.enableZoom === false) return;\n          if (state !== STATE.TOUCH_DOLLY) return;\n          var dx = event.touches[0].pageX - event.touches[1].pageX;\n          var dy = event.touches[0].pageY - event.touches[1].pageY;\n          var distance = Math.sqrt(dx * dx + dy * dy);\n          dollyEnd.set(0, distance);\n          dollyDelta.subVectors(dollyEnd, dollyStart);\n\n          if (dollyDelta.y > 0) {\n            constraint.dollyOut(getZoomScale());\n          } else if (dollyDelta.y < 0) {\n            constraint.dollyIn(getZoomScale());\n          }\n\n          dollyStart.copy(dollyEnd);\n          scope.update();\n          break;\n\n        case 3:\n          // three-fingered touch: pan\n          if (scope.enablePan === false) return;\n          if (state !== STATE.TOUCH_PAN) return;\n          panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n          panDelta.subVectors(panEnd, panStart);\n          pan(panDelta.x, panDelta.y);\n          panStart.copy(panEnd);\n          scope.update();\n          break;\n\n        default:\n          state = STATE.NONE;\n      }\n    }\n\n    function touchend()\n    /* event */\n    {\n      if (scope.enabled === false) return;\n      scope.dispatchEvent(endEvent);\n      state = STATE.NONE;\n    }\n\n    function contextmenu(event) {\n      event.preventDefault();\n    }\n\n    this.dispose = function () {\n      this.domElement.removeEventListener('contextmenu', contextmenu, false);\n      this.domElement.removeEventListener('mousedown', onMouseDown, false);\n      this.domElement.removeEventListener('mousewheel', onMouseWheel, false);\n      this.domElement.removeEventListener('MozMousePixelScroll', onMouseWheel, false); // firefox\n\n      this.domElement.removeEventListener('touchstart', touchstart, false);\n      this.domElement.removeEventListener('touchend', touchend, false);\n      this.domElement.removeEventListener('touchmove', touchmove, false);\n      document.removeEventListener('mousemove', onMouseMove, false);\n      document.removeEventListener('mouseup', onMouseUp, false);\n      window.removeEventListener('keydown', onKeyDown, false);\n    };\n\n    this.domElement.addEventListener('contextmenu', contextmenu, false);\n    this.domElement.addEventListener('mousedown', onMouseDown, false);\n    this.domElement.addEventListener('mousewheel', onMouseWheel, false);\n    this.domElement.addEventListener('MozMousePixelScroll', onMouseWheel, false); // firefox\n\n    this.domElement.addEventListener('touchstart', touchstart, false);\n    this.domElement.addEventListener('touchend', touchend, false);\n    this.domElement.addEventListener('touchmove', touchmove, false);\n    window.addEventListener('keydown', onKeyDown, false); // force an update at start\n\n    this.update();\n  }\n\n  ;\n  OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);\n  OrbitControls.prototype.constructor = OrbitControls;\n  Object.defineProperties(OrbitControls.prototype, {\n    object: {\n      get: function get() {\n        return this.constraint.object;\n      }\n    },\n    target: {\n      get: function get() {\n        return this.constraint.target;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: target is now immutable. Use target.set() instead.');\n        this.constraint.target.copy(value);\n      }\n    },\n    minDistance: {\n      get: function get() {\n        return this.constraint.minDistance;\n      },\n      set: function set(value) {\n        this.constraint.minDistance = value;\n      }\n    },\n    maxDistance: {\n      get: function get() {\n        return this.constraint.maxDistance;\n      },\n      set: function set(value) {\n        this.constraint.maxDistance = value;\n      }\n    },\n    minZoom: {\n      get: function get() {\n        return this.constraint.minZoom;\n      },\n      set: function set(value) {\n        this.constraint.minZoom = value;\n      }\n    },\n    maxZoom: {\n      get: function get() {\n        return this.constraint.maxZoom;\n      },\n      set: function set(value) {\n        this.constraint.maxZoom = value;\n      }\n    },\n    minPolarAngle: {\n      get: function get() {\n        return this.constraint.minPolarAngle;\n      },\n      set: function set(value) {\n        this.constraint.minPolarAngle = value;\n      }\n    },\n    maxPolarAngle: {\n      get: function get() {\n        return this.constraint.maxPolarAngle;\n      },\n      set: function set(value) {\n        this.constraint.maxPolarAngle = value;\n      }\n    },\n    minAzimuthAngle: {\n      get: function get() {\n        return this.constraint.minAzimuthAngle;\n      },\n      set: function set(value) {\n        this.constraint.minAzimuthAngle = value;\n      }\n    },\n    maxAzimuthAngle: {\n      get: function get() {\n        return this.constraint.maxAzimuthAngle;\n      },\n      set: function set(value) {\n        this.constraint.maxAzimuthAngle = value;\n      }\n    },\n    enableDamping: {\n      get: function get() {\n        return this.constraint.enableDamping;\n      },\n      set: function set(value) {\n        this.constraint.enableDamping = value;\n      }\n    },\n    dampingFactor: {\n      get: function get() {\n        return this.constraint.dampingFactor;\n      },\n      set: function set(value) {\n        this.constraint.dampingFactor = value;\n      }\n    },\n    // backward compatibility\n    noZoom: {\n      get: function get() {\n        console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');\n        return !this.enableZoom;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');\n        this.enableZoom = !value;\n      }\n    },\n    noRotate: {\n      get: function get() {\n        console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');\n        return !this.enableRotate;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');\n        this.enableRotate = !value;\n      }\n    },\n    noPan: {\n      get: function get() {\n        console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');\n        return !this.enablePan;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');\n        this.enablePan = !value;\n      }\n    },\n    noKeys: {\n      get: function get() {\n        console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');\n        return !this.enableKeys;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');\n        this.enableKeys = !value;\n      }\n    },\n    staticMoving: {\n      get: function get() {\n        console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');\n        return !this.constraint.enableDamping;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');\n        this.constraint.enableDamping = !value;\n      }\n    },\n    dynamicDampingFactor: {\n      get: function get() {\n        console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');\n        return this.constraint.dampingFactor;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');\n        this.constraint.dampingFactor = value;\n      }\n    }\n  });\n  return OrbitControls;\n};\n\n//# sourceURL=webpack:///./src/js/utils/orbitControls.js?");

/***/ }),

/***/ 0:
/*!************************************!*\
  !*** multi ./src/js/appJupyter.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/js/appJupyter.js */\"./src/js/appJupyter.js\");\n\n\n//# sourceURL=webpack:///multi_./src/js/appJupyter.js?");

/***/ })

},[[0,"runtime","vendors"]]]);