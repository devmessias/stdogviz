{"version":3,"sources":["webpack:///./src/js/graph/helpers/stats.js","webpack:///./src/js/graph/components/renderer/main.js","webpack:///./src/js/data/config.js","webpack:///./src/js/graph/components/nodes/shaders/marker.vsh.js","webpack:///./src/js/graph/components/nodes/shaders/marker.fsh.js","webpack:///./src/js/graph/helpers/tools.js","webpack:///./src/js/graph/components/nodes/main.js","webpack:///./src/js/graph/components/edges/main.js","webpack:///./src/js/utils/keyboard.js","webpack:///./src/js/graph/interactions/keyboard.js","webpack:///./src/js/graph/interactions/datGUI.js","webpack:///./src/js/graph/main.js","webpack:///./src/js/connections/dataPool.js","webpack:///./src/js/app.js"],"names":["rS","bS","glS","tS","Stats","renderer","this","start","tick","frame","end","update","BrowserStats","glStats","threeStats","rStats","CSSPath","userTimingAPI","values","caption","over","average","avgMs","fps","below","calls","raf","rstats","texture","groups","fractions","base","steps","plugins","saveDataURI","name","dataURI","blob","binStr","window","atob","split","len","length","arr","Uint8Array","i","charCodeAt","Blob","dataURIToBlob","link","document","createElement","download","href","URL","createObjectURL","onclick","setTimeout","revokeObjectURL","removeAttribute","click","Renderer","useHighQuality","useBloom","useStats","scene","controls","container","canvas","camera","appState","dataPool","THREE","antialias","preserveDrawingBuffer","alpha","autoClear","stats","setUp","setPixelRatio","devicePixelRatio","shadowMap","enabled","type","initComposer","initBloomComposer","initFXAAComposer","updateSize","offsetWidth","offsetHeight","addEventListener","render","bind","takeScreenshot","btnSave","getElementById","event","takeScreenshotModal","composer","EffectComposer","renderPass","RenderPass","addPass","console","info","toneMapping","BloomPass","bloomPass","UnrealBloomPass","innerWidth","innerHeight","fxaaPass","ShaderPass","FXAAShader","pixelRatio","getPixelRatio","material","uniforms","value","x","y","widthRender","heightRender","keepPos","aspect","change","originalAspect","newSize","left","right","top","bottom","updateProjectionMatrix","clientWidth","clientHeight","setCameraAspect","setSize","removeEventListener","widthImage","heightImage","saveWithTransparency","color","background","setClearColor","toDataURL","takingScreenshot","stopChanges","getURI","$","modal","ext","parseInt","checked","send2server","DataURI","Date","toLocaleDateString","toLocaleTimeString","replace","address","isDev","isShowingStats","useGuiControl","useKeyboard","isLoaded","isMouseMoving","isMouseOver","maxAnisotropy","exposure","strength","threshold","radius","dpr","layers","0","1","clearColor","bloomStrength","bloomThreshold","bloomRadius","2","3","nodes","scale","show","edgeColor","edgeWidth","roughness","opacity","edges","width","fog","near","fov","far","autoRotate","autoRotateSpeed","rotateSpeed","zoomSpeed","minDistance","maxDistance","minPolarAngle","maxPolarAngle","Math","PI","minAzimuthAngle","Infinity","maxAzimuthAngle","enableDamping","dampingFactor","enableZoom","target","z","getMarkerVertexShader","fixedNodeSize","fixedColor","nodesGroupName","markerVertexShader","distFunctions","getDistFunction","marker","Object","keys","includes","getShading","getMarkerFragmentShader","availableMarkers","randomString","random","toString","substring","randomChoice","floor","Nodes","use2d","nodesGroup","selectedGroupName","groupName","allGroups","entries","prop","getGroup","nodesObj","bufferColors","nodesData","flat","numNodes","alertify","error","updateColors","colors","mesh","vertexShader","geometry","addAttribute","Float32Array","needsUpdate","attributes","array","colormap","nshades","format","map","index","String","sort","val1","r","g","b","deleteAttribute","fragmentShader","updateMarker","colorHEX","updateColor","bufferNodeSize","updateSizes","sizes","sMin","min","sMax","max","s","sizesBuffer","bufferNodeSizes","size","instancedNodes","bufferRadius","bufferOpacity","bufferNodeScale","positions","bufferNodePositions","key","dispose","remove","clear","props","id","deleteAllNodes","nodesMesh","pos","instancedGeometry","markerGeometry","copy","maxInstancedCount","Config","transparent","depthTest","depthWrite","add","Edges","layer","bloomLayer","createEdges","numEdges","edgesData","instancedEdges","positionVertices","f","push","id_t","position","computeBoundingSphere","colorHex","linewidth","alert","createVertices","updateGeometry","setFromPoints","vertices","defaultProps","segments","t","deleteAllEdges","vertexColors","blending","setAttribute","ALIAS","Keyboard","domElement","keyCodes","onKeyChange","onBlur","keyCode","keyDesc","pressed","indexOf","toUpperCase","aliases","aliasKeys","shiftKey","ctrlKey","altKey","metaKey","Interaction","datGui","keypressFunc","timeout","keyboard","keypressEvent","repeat","toLowerCase","message","closed","vimMode","confirm","updateDropdown","list","innerHTMLStr","children","innerHTML","DatGUI","idCanvasHTML","nodes0","edges0","gui","dat","autoPlace","appendChild","addFolder","addColor","onChange","nodesFolder","comunityField","setComunity","changeMarker","visible","changeColor","sizeField","sizeByField","changeScale","changeEdgeColor","changeEdgeWidth","changeOpacity","colorProp","colorByProp","colorField","colorByField","edgesFolder","changeWidth","colorEdge","field","colorEdgeField","changeColorUniform","renderFolder","toneMappingExposure","pow","Number","step","unshift","filter","v","colorEdgeProp","Graph","keyboardPressFunction","showStats","state","firstLoad","renders","rendering","OrbitControls","set","enableKeys","screenSpacePanning","enableRotate","group","groupEnd","keyboardInteraction","boundingSphere","center","lookAt","height","transparency","uri","stop","DataPool","listenerFunction","ws","io","connect","on","warning","data","emit","room","getGraph","open","readyState","OPEN","WebSocket","imgURI","time","nodesId","isOpen","send","JSON","stringify","queryString","location","search","urlParams","URLSearchParams","has","get","graphObj","action","dataPoolSocket","recalcPos","reloadGraph","graphObjVar","clearInterval","intervalGetGraph","timeEnd","createNodes","ressetLook","stopUpdate","updateNodeColorProp","updateComunityField","updateNodePositions","init","setInterval"],"mappings":"2JACIA,EAAIC,EAAIC,EAAKC,E,wPAEIC,E,WACnB,WAAYC,I,4FAAU,SACpBC,KAAKD,SAAWA,E,sDA+BhBL,EAAG,SAASO,QACZL,EAAIK,QAEJP,EAAG,OAAOQ,OACVR,EAAG,OAAOS,QAEVT,EAAG,UAAUO,U,4BAIbP,EAAG,UAAUU,MACbV,EAAG,SAASU,MAGZV,EAAG,UAAUO,QACbP,IAAKW,SACLX,EAAG,UAAUU,U,iCA3CbT,EAAK,IAAIW,aACTV,EAAM,IAAIW,QACVV,EAAK,IAAIW,WAAWR,KAAKD,UAEzBL,EAAK,IAAIe,OAAO,CACdC,QAAS,SACTC,eAAe,EACfC,OAAQ,CACNT,MAAO,CAAEU,QAAS,wBAAyBC,KAAM,GAAIC,SAAS,EAAMC,MAAO,KAC3EC,IAAK,CAAEJ,QAAS,kBAAmBK,MAAO,IAC1CC,MAAO,CAAEN,QAAS,mBAAoBC,KAAM,KAC5CM,IAAK,CAAEP,QAAS,2BAA4BE,SAAS,EAAMC,MAAO,KAClEK,OAAQ,CAAER,QAAS,qBAAsBE,SAAS,EAAMC,MAAO,KAC/DM,QAAS,CAAET,QAAS,SAAUE,SAAS,EAAMC,MAAO,MAEtDO,OAAQ,CACN,CAAEV,QAAS,YAAaD,OAAQ,CAAC,MAAO,QACxC,CAAEC,QAAS,eAAgBD,OAAQ,CAAC,QAAS,UAAW,QAAS,YAEnEY,UAAW,CACT,CAAEC,KAAM,QAASC,MAAO,CAAC,UAAW,QAAS,YAE/CC,QAAS,CAAChC,EAAIE,EAAID,U,sMCKxB,SAASgC,EAAaC,EAAMC,GACxB,IAAMC,EAhBV,SAAwBD,GAIpB,IAHA,IAAME,EAASC,OAAOC,KAAMJ,EAAQK,MAAO,KAAM,IAC3CC,EAAMJ,EAAOK,OACbC,EAAM,IAAIC,WAAYH,GAClBI,EAAI,EAAGA,EAAIJ,EAAKI,IACtBF,EAAIE,GAAKR,EAAOS,WAAYD,GAEhC,OAAO,IAAIP,OAAOS,KAAM,CAACJ,IASZK,CAAeb,GAGtBc,EAAOC,SAASC,cAAe,KACrCF,EAAKG,SAAWlB,EAChBe,EAAKI,KAAOf,OAAOgB,IAAIC,gBAAiBnB,GACxCa,EAAKO,QAAU,WACXlB,OAAOmB,YAAY,WACfnB,OAAOgB,IAAII,gBAAiBtB,GAC5Ba,EAAKU,gBAAiB,UACvB,MAGPV,EAAKW,Q,IAgBYC,E,WACjB,WACIC,EACAC,EACAC,EACAC,EAAOC,EAAUC,EAAWC,EAAQC,EAAQC,EAAWC,GAAU,Y,4FAAA,SACjElE,KAAK4D,MAAQA,EACb5D,KAAK6D,SAAWA,EAChB7D,KAAK+D,OAASA,EACd/D,KAAK8D,UAAYA,EACjB9D,KAAKgE,OAASA,EACdhE,KAAKiE,SAAWA,EAChBjE,KAAKkE,SAAWA,EAGhBlE,KAAKyD,eAAiBA,EACtBzD,KAAK0D,SAAWA,EAChB1D,KAAK2D,SAAWA,EAEhB3D,KAAKD,SAAW,IAAIoE,IAChB,CACIJ,OAAQA,EACRK,UAAWX,EACXY,uBAAuB,EACvBC,OAAM,IAGdtE,KAAKD,SAASwE,WAAY,EACvBvE,KAAK2D,WACJ3D,KAAKwE,MAAQ,IAAI1E,EAAME,KAAKD,UAC5BC,KAAKwE,MAAMC,SAGfzE,KAAKD,SAAS2E,cAAczC,OAAO0C,kBAGnC3E,KAAKD,SAAS6E,UAAUC,SAAU,EAClC7E,KAAKD,SAAS6E,UAAUE,KAAOX,KAK3BV,GAAkBC,IAClB1D,KAAK+E,eAELrB,GACA1D,KAAKgF,oBAELvB,GACAzD,KAAKiF,mBAKTjF,KAAKkF,WAAWlF,KAAK+D,OAAOoB,YAAYnF,KAAK+D,OAAOqB,cAEpDvC,SAASwC,iBAAiB,oBAAoB,kBAAM,EAAKH,gBAAc,GACvEjD,OAAOoD,iBAAiB,UAAU,kBAAM,EAAKH,gBAAc,GAG3DlF,KAAK6D,SAASwB,iBAAiB,UAAU,kBAAI,EAAKC,YAElDtF,KAAKsF,OAAStF,KAAKsF,OAAOC,KAAKvF,MAC/BA,KAAKkF,WAAalF,KAAKkF,WAAWK,KAAKvF,MAEvCA,KAAKwF,eAAiBxF,KAAKwF,eAAeD,KAAKvF,MAC/C,IAAMyF,EAAU5C,SAAS6C,eAAe,gBACrCD,GACCA,EAAQJ,iBAAiB,SAAU,SAAAM,GAAK,OAAE,EAAKC,yB,8DAInD5F,KAAK6F,SAAW,IAAIC,IAAgB9F,KAAKD,UACzC,IAAIgG,EAAa,IAAIC,IAAYhG,KAAK4D,MAAO5D,KAAKgE,QAClDhE,KAAK6F,SAASI,QAASF,K,0CAIvBG,QAAQC,KAAK,cAEbnG,KAAKD,SAASqG,YAAcjC,IACV,IAAIkC,IAClB,EACA,GACA,EACA,KAKJrG,KAAKsG,UAAY,IAAIC,IACjB,IAAIpC,IAAelC,OAAOuE,WAAYvE,OAAOwE,aAJhC,EACF,EACG,GAIlBzG,KAAK6F,SAASI,QAAQjG,KAAKsG,a,yCAI3BJ,QAAQC,KAAK,aAEb,IAAIO,EAAW,IAAIC,IAAYC,KAEzBC,EAAa7G,KAAKD,SAAS+G,gBAEjCJ,EAASK,SAASC,SAAlB,WAA2CC,MAAMC,EAAI,GAAMlH,KAAK+D,OAAOoB,YAAc0B,GACrFH,EAASK,SAASC,SAAlB,WAA2CC,MAAME,EAAI,GAAMnH,KAAK+D,OAAOqB,aAAeyB,GACtF7G,KAAK0G,SAAWA,EAChB1G,KAAK6F,SAASI,QAASS,K,sCAGXU,EAAaC,GAA4B,IAAdC,IAAc,yDAMrD,GAJetH,KAAK+D,OAIjBuD,EAAQ,CACP,IAAMC,EAASH,EAAcC,EACvBG,EAASxH,KAAKiE,SAASwD,eAAeF,EAEtCG,EAAU,EAAIF,EACpBxH,KAAKgE,OAAO2D,MAAQJ,EAASG,EAAU,EACvC1H,KAAKgE,OAAO4D,MAAQL,EAASG,EAAW,EACxC1H,KAAKgE,OAAO6D,IAAMH,EAAU,EAC5B1H,KAAKgE,OAAO8D,QAAUJ,EAAU,EAEpC1H,KAAKgE,OAAOuD,OAASH,EAAcC,EAEnCrH,KAAKgE,OAAO+D,2B,iCAELX,EAAaC,GAA4B,IAAdC,IAAc,yDAehD,GAdAF,EAAcA,GAAepH,KAAK8D,UAAUkE,YAC5CX,EAAcA,GAAerH,KAAK8D,UAAUmE,aAE5CjI,KAAKkI,gBAAgBd,EAAaC,EAAcC,GAE5CtH,KAAKyD,gBAAkBzD,KAAK0D,UAE5B1D,KAAKD,SAASoI,QAAQf,EAAaC,GACnCrH,KAAK6F,SAASsC,QAASf,EAAaC,IAEpCrH,KAAKD,SAASoI,QAAQf,EAAaC,GAInCrH,KAAKyD,eAAe,CACpB,IAAMoD,EAAa7G,KAAKD,SAAS+G,gBACjC9G,KAAK0G,SAASK,SAASC,SAAvB,WAAgDC,MAAMC,EAAI,GAAME,EAAcP,GAC9E7G,KAAK0G,SAASK,SAASC,SAAvB,WAAgDC,MAAME,EAAI,GAAME,EAAeR,GAGnF7G,KAAKsF,W,+BAgCFtF,KAAK2D,UACJ7D,EAAMG,QAIND,KAAKyD,gBAAkBzD,KAAK0D,SAG5B1D,KAAK6F,SAASP,SAEdtF,KAAKD,SAASuF,OAAOtF,KAAK4D,MAAO5D,KAAKgE,QAEvChE,KAAK2D,UACJ7D,EAAMM,Q,+BAIN,WACJJ,KAAKsF,OAAS,kBAAI,GAClBzC,SAASuF,oBAAoB,oBAAoB,kBAAM,EAAKlD,gBAAc,GAC1EjD,OAAOmG,oBAAoB,UAAU,kBAAM,EAAKlD,gBAAc,GAC9D,IAAMO,EAAU5C,SAAS6C,eAAe,gBACrCD,GACCA,EAAQ2C,oBAAoB,SAAU,SAAAzC,GAAK,OAAE,EAAKH,sB,6BAKtDxF,KAAA,W,6BAEGqI,EAAYC,EAAaC,GAC5BF,EAAaA,GAAcrI,KAAK8D,UAAUkE,YAC1CM,EAAaA,GAActI,KAAK8D,UAAUmE,aAG1CjI,KAAKkI,gBAAgBG,EAAYC,GAAa,GAK9C,IAAME,EAAQxI,KAAK4D,MAAM6E,WACtBF,IACCvI,KAAKD,SAAS2I,cAAe,EAAU,GACvC1I,KAAK4D,MAAM6E,WAAa,MAE5BzI,KAAKD,SAASoI,QAAUE,EAAYC,GAIpCtI,KAAK6F,SAASsC,QAASE,EAAYC,GACnCtI,KAAK6F,SAASP,SAEd,IAAMxD,EAAU9B,KAAK+D,OAAO4E,UAAW,YAAa,GAQpD,OANGJ,IACCvI,KAAK4D,MAAM6E,WAAaD,GAC5BxI,KAAKiE,SAAS2E,kBAAmB,EAEjC5I,KAAKkF,aAEEpD,I,qCAEIuG,EAAYC,EAAaC,GAKpC,OAJAvI,KAAKiE,SAAS2E,kBAAmB,EACjC5I,KAAKiE,SAAS4E,aAAc,EAEZ7I,KAAK8I,OAAOT,EAAYC,EAAaC,K,4CAKrDQ,EAAE,mBAAmBC,MAAM,QAC3BhJ,KAAKiE,SAAS2E,kBAAmB,EACjC5I,KAAKiE,SAAS4E,aAAc,EAC5B,IAtQkBI,EAsQZZ,EAAaa,SAASrG,SAAS6C,eAAe,kBAAkBuB,OAChEqB,EAAcY,SAASrG,SAAS6C,eAAe,mBAAmBuB,OAElEsB,EAAuB1F,SAAS6C,eAAe,wBAAwByD,QAEvEC,EAAcvG,SAAS6C,eAAe,eAAeyD,QAErDE,EAAUrJ,KAAK8I,OAAOT,EAAYC,EAAaC,GACjDa,GAAepJ,KAAKkE,SACpBlE,KAAKkE,SAASkF,YAAYC,GAE1BzH,GAjRcqH,EAiRc,OAhRxB,GAAH,QAAM,IAAIK,MAAOC,qBAAjB,gBAA4C,IAAID,MAAOE,sBAAvD,OAA8EP,GAC5EQ,QAAQ,MAAO,KAAKA,QAAQ,KAAM,MA+QAJ,Q,iDC5UlC,GACXK,QAAS,iBACT9F,MAAO,CACH4E,MAAO,GAGXmB,OAAO,EACPrE,OAAO,CACHlB,WAAW,GAEfwF,gBAAgB,EAChBjG,UAAU,EACVkG,eAAe,EACfC,aAAa,EACbC,UAAU,EACVC,eAAe,EACfC,aAAa,EACbC,cAAe,EACf5D,UAAW,CACP6D,SAAU,EACVC,SAAU,GACVC,UAAW,EACXC,OAAQ,GAGZC,IAAK,EACLC,OAAO,CACHC,EAAE,GACFC,EAAE,CACE7F,SAAQ,EAER8F,WAAY,EACZR,SAAU,EACVC,SAAU,GACVQ,cAAe,EACfC,eAAgB,EAChBC,YAAa,GAEjBC,EAAE,GACFC,EAAE,CAEEnG,SAAQ,EACRsF,SAAU,EAEVQ,WAAY,EACZP,SAAU,GACVQ,cAAe,EACfC,eAAgB,EAChBC,YAAa,EACrBlH,MAAO,oBAGPqH,MAAO,CACHlE,SAAU,OACVmE,MAAM,EACNC,MAAM,EACNb,OAAQ,GACR9B,MAAO,IACP4C,UAAW,IACXC,UAAW,GACXC,UAAW,GACXC,QAAS,GAGbC,MAAO,CACHC,MAAO,GACPN,MAAM,EACN3C,MAAO,IAEP8C,UAAW,GACXC,QAAS,GAIbG,IAAK,CACDlD,MAAO,SACPmD,KAAM,MAEV3H,OAAQ,CACJ4H,IAAK,GACLD,KAAM,EACNE,IAAK,IACLtE,OAAQ,GAEZ1D,SAAU,CACNiI,YAAY,EACZC,iBAAkB,GAClBC,YAAa,GACbC,UAAW,GACXC,YAAa,EACbC,YAAa,IACbC,cAAc,EACdC,cAAeC,KAAKC,GACpBC,iBAAkBC,IAClBC,gBAAiBD,IACjBE,eAAe,EACfC,cAAe,GACfC,YAAY,EACZC,OAAQ,CACJ5F,EAAG,EACHC,EAAG,EACH4F,EAAG,KCrGR,SAASC,IAAmF,IAA7DC,EAA6D,wDAAxCC,EAAwC,wDAAtBC,EAAsB,uDAAP,OACxFjH,QAAQC,KAAK,4BACb,IAAIiH,EAAqB,0CAAH,OAEWD,EAFX,0LAyDtB,OA5CIC,GADAH,EACsB,gCAEA,kCAGtBG,GADAF,EACsB,6BAGA,+BAG1BE,GAAsB,w3BCc1B,IAAMC,EAAgB,CAClB,0GAKA,oLAOA,yUAUA,4SAUA,2ZAWA,gUAWA,yXAYA,4MAUA,qaAgBJ,SAASC,EAAgBC,GAKrB,OAJcC,OAAOC,KAAKJ,GAAeK,SAASH,KAE9CA,EAAS,KAENF,EAAcE,GAGzB,SAASI,EAAWJ,GAEhB,MAAc,OAAVA,EACO,IAEE,2rBAgBV,SAASK,EAAwBL,GAA8B,IAAtBJ,EAAsB,uDAAP,OAE3D,OADAjH,QAAQC,KAAKoH,GACb,6EAGiCJ,EAHjC,oeAwBMG,EAAgBC,GAxBtB,6PA+BMI,EAAWJ,GA/BjB,mNA8CG,IAAMM,EAAmB,CAC5B,OAAU,IACV,OAAU,MACV,OAAU,IACV,QAAY,IACZ,SAAa,IACb,QAAY,IACZ,QAAY,IACZ,KAAS,KACT,MAAS,IACT,EAAK,KCzNIC,EAAe,kBAAIxB,KAAKyB,SAASC,SAAS,IAAIC,UAAU,EAAG,KAO3DC,EAAe,SAAC5L,GAAD,OAASA,EAAIgK,KAAK6B,MAAM7L,EAAID,OAASiK,KAAKyB,Y,8gECOjDK,E,WAMjB,WAAYxK,EAAOyK,I,4FAAO,SACtBrO,KAAK4D,MAAQA,EACb5D,KAAKqO,MAAQA,EAEbrO,KAAKsO,WAAa,GAIlBtO,KAAKuO,kBAAoB,G,wDAQpBC,GACLxO,KAAKuO,kBAAoBf,OAAOC,KAAKzN,KAAKsO,YAAYZ,SAASzG,OAAQA,MAAQ,K,iCAS/E,IAAMwH,EAAYjB,OAAOkB,QAAQ1O,KAAKsO,YAEtC,MADsC,IAA1BtO,KAAKuO,kBAAyB,CAAC,CAACvO,KAAKuO,kBAAmBvO,KAAKsO,WAAWtO,KAAKuO,qBAAuBE,I,mCAQvGE,GAAK,UAC2B3O,KAAK4O,YADhC,IACd,2BAA2D,oBAA/CzB,EAA+C,KAA/B0B,EAA+B,KAEnDC,EAAeD,EAASE,UAAUJ,GAAMK,OAC5C,GAAIF,EAAazM,QAA4B,EAAlBwM,EAASI,SAEhC,YADAC,IAASC,MAAT,WAAmBR,EAAnB,6BAGA3O,KAAKoP,aAAaN,EAAc3B,IAR1B,iC,mCAcLkC,EAAQlC,GAEjB,IAAI0B,EAAW7O,KAAKsO,WAAWnB,GAC3B0B,EAAS3B,YAET2B,EAASS,KAAKvI,SAASwI,aAAevC,EAAsB6B,EAAS5B,eADpD,EAC+EE,GAEhG0B,EAASS,KAAKE,SAASC,aAAa,eAChC,IAAItL,IAA+B,IAAIuL,aAAaL,GAAS,GAAG,IAEpER,EAAS3B,YANQ,SAOV2B,EAAS7H,SAAS8H,aACzBD,EAASS,KAAKE,SAASG,aAAc,IAGrCd,EAASS,KAAKE,SAASI,WAAWd,aAAae,MAAQ,IAAIH,aAAaL,GACxER,EAASS,KAAKE,SAASI,WAAWd,aAAaa,aAAc,GAIjEd,EAASS,KAAKvI,SAAS4I,aAAc,I,kCAI7BhB,GAAK,iBAE4B3O,KAAK4O,YAFjC,wCAEDzB,EAFC,KAEe0B,EAFf,KAILQ,EAASS,IAAS,CAClBA,SAAU,MACVC,QAASlB,EAASI,SAClBe,OAAQ,QACR1L,MAAO,IAEP1D,EAASiO,EAASE,UAAUJ,GAE1BG,EAAeO,EAChBY,KAAI,SAACzH,EAAO0H,GAAR,MAAkB,CAACtP,EAAOuP,OAAOD,IAAS1H,MAC9C4H,MAAK,kBAAEC,EAAF,2BAA2BA,KAChCJ,KAAI,gCACJA,KAAI,yBAAEK,EAAF,KAAKC,EAAL,KAAQC,EAAR,iBAAoB,CAACF,EAAGC,EAAGC,MAC/BxB,OACL,EAAKI,aAAaN,EAAc3B,IAhBpC,2BAA2D,IAF9C,iC,kCAsBL3E,EAAO2E,GAEf,IAAI0B,EAAW7O,KAAKsO,WAAWnB,GAC3B0B,EAAS3B,WACT2B,EAAS7H,SAAS8H,aAAa7H,MAAQuB,GAIvCqG,EAAS7H,SAAS8H,aAAe,CAC7BhK,KAAM,OACNmC,MAAOuB,GAEXqG,EAASS,KAAKE,SAASiB,gBAAgB,gBACvC5B,EAASS,KAAKvI,SAASwI,aAAevC,EAAsB6B,EAAS5B,eANpD,EAM+EE,GAEhG0B,EAAS3B,YAAa,EACtB2B,EAASS,KAAKE,SAASG,aAAc,EACrCd,EAAS3B,YAAa,GAE1B2B,EAASS,KAAKvI,SAAS4I,aAAc,I,mCAG5BpC,EAAQJ,GAEjB,IAAI0B,EAAW7O,KAAKsO,WAAWnB,GAC/B0B,EAASS,KAAKvI,SAASwI,aAAevC,EAClC6B,EAAS5B,cAAe4B,EAAS3B,WAAYC,GAEjD0B,EAASS,KAAKvI,SAAS2J,eAAiB9C,EACpCL,EAAQJ,GAEZ0B,EAASS,KAAKvI,SAAS4I,aAAc,I,mCAI5BpC,GAAO,UAEyBvN,KAAK4O,YAF9B,IAEhB,2BAA2D,oBAA/CzB,EAA+C,UACvDnN,KAAK2Q,aAAapD,EAAQJ,IAHd,iC,mCAOR,UAEiCnN,KAAK4O,YAFtC,IAER,2BAA2D,oBAA/BC,GAA+B,WACvDA,EAASS,KAAKE,SAASG,aAAc,EACrCd,EAASS,KAAKvI,SAAS4I,aAAa,GAJhC,iC,kCAUAiB,GAAS,UAEwB5Q,KAAK4O,YAF7B,IAEjB,2BAA2D,oBAA/CzB,EAA+C,KACnD3E,GADmD,KAC3C,IAAIrE,IAAYyM,IAC5B5Q,KAAK6Q,YAAYrI,EAAO2E,IAJX,iC,kCASTwB,GAAK,UAE4B3O,KAAK4O,YAFjC,IAEb,2BAA2D,oBAA/CzB,EAA+C,KAA/B0B,EAA+B,KAEnDiC,EAAiBjC,EAASE,UAAUJ,GAAMK,OAC9C,GAAI8B,EAAezO,QAAUwM,EAASI,SAElC,YADAC,IAASC,MAAT,WAAmBR,EAAnB,iCAGA3O,KAAK+Q,YAAYD,EAAgB3D,IAT5B,iC,kCAeL6D,EAAO7D,GAEf,IAAI0B,EAAW7O,KAAKsO,WAAWnB,GAC3B8D,EAAO3E,KAAK4E,IAAL,MAAA5E,KAAI,EAAQ0E,IACnBG,EAAO7E,KAAK8E,IAAL,MAAA9E,KAAI,EAAQ0E,IAEvB,GADAA,EAAQA,EAAMf,KAAI,SAACoB,GAAD,OAAOA,EAAEJ,IAAOE,EAAKF,MACnCpC,EAAS5B,cAAc,CAEvB4B,EAASS,KAAKvI,SAASwI,aAAevC,GADlB,EACuD6B,EAAS3B,WAAYC,GAGhG,IAAImE,EAAc,IAAInN,IAA+B,IAAIuL,aAAasB,GAAQ,GAAG,GACjFnC,EAASS,KAAKE,SAASC,aAAa,iBAChC6B,GAEJzC,EAAS5B,eARW,SASb4B,EAAS7H,SAASuK,gBACzB1C,EAASS,KAAKE,SAASG,aAAc,OAGrCd,EAASS,KAAKE,SAASI,WAAW2B,gBAAgB1B,MAAQ,IAAIH,aAAasB,GAC3EnC,EAASS,KAAKE,SAASI,WAAW2B,gBAAgB5B,aAAc,EAGpEd,EAASS,KAAKvI,SAAS4I,aAAc,I,iCAI9B6B,EAAMrE,GAEb,IAAI0B,EAAW7O,KAAKsO,WAAWnB,GAC3B0B,EAAS5B,cACT4B,EAAS7H,SAASuK,gBAAgBtK,MAAQuB,OAI1CqG,EAAS7H,SAASuK,gBAAkB,CAChCzM,KAAM,OACNmC,MAAOuB,OAEXqG,EAASS,KAAKE,SAASiB,gBAAgB,mBACvC5B,EAASS,KAAKvI,SAASwI,aAAevC,EAAsB6B,EAAS5B,eANjD,EAM+EE,GACnG0B,EAAS5B,eAAgB,EACzB4B,EAASS,KAAKE,SAASG,aAAc,EACrCd,EAAS5B,eAAgB,GAE7B4B,EAASS,KAAKvI,SAAS4I,aAAc,I,mCAM5B1I,GACTjH,KAAKyR,eAAejC,SAASI,WAAW8B,aAAezK,EACvDjH,KAAKyR,eAAe1K,SAAS4I,aAAc,I,sCAG/BnH,GAAM,UACuBxI,KAAK4O,YAD5B,IAClB,2BAA2D,oBAA/BC,GAA+B,WAEvDA,EAAS7H,SAASoE,UAAUnE,MAAQ,IAAI9C,IAAYqE,GACpDqG,EAASS,KAAKE,SAASG,aAAc,GAJvB,iC,sCAON1I,GAAM,UAEuBjH,KAAK4O,YAF5B,IAElB,2BAA2D,oBAA/BC,GAA+B,WAEvDA,EAAS7H,SAASqE,UAAUpE,MAAQA,EACpC4H,EAASS,KAAKE,SAASG,aAAc,GALvB,iC,oCASR1I,GAAM,UAEyBjH,KAAK4O,YAF9B,IAEhB,2BAA2D,oBAA/BC,GAA+B,WAEvDA,EAAS7H,SAAS2K,cAAc1K,MAAQA,EACxC4H,EAASS,KAAKE,SAASG,aAAc,GALzB,iC,kCAQR1I,GAAM,UAE2BjH,KAAK4O,YAFhC,IAEd,2BAA2D,oBAA/BC,GAA+B,WAEvDA,EAAS7H,SAAS4K,gBAAgB3K,MAAQA,EAC1C4H,EAASS,KAAKE,SAASG,aAAc,EACrCd,EAASS,KAAKvI,SAAS4I,aAAc,GAN3B,iC,0CAUEkC,GAChB7R,KAAKyR,eAAejC,SAASI,WAAWkC,oBAAoBjC,MAAQ,IAAIH,aAAamC,GACrF7R,KAAKyR,eAAejC,SAASI,WAAWkC,oBAAoBnC,aAAc,I,uCAM1E,cAA8BnC,OAAOkB,QAAQ1O,KAAKsO,YAAlD,eAA+D,iBAAnDyD,EAAmD,KAA9ClD,EAA8C,KAC3DA,EAASS,KAAKE,SAASwC,UACvBnD,EAASS,KAAKvI,SAASiL,UACvBnD,EAASS,KAAKE,SAASG,aAAc,EACrCd,EAASS,KAAKvI,SAAS4I,aAAc,EACrC3P,KAAK4D,MAAMqO,OAAOpD,EAASS,aACpBtP,KAAKsO,WAAWyD,M,kCAGnBhD,GAAyB,IAC7B5B,EADgB+E,EAAa,wDAG7B/E,EADA+E,EACiB,OAEAnD,EAAUoD,MAAMzE,SAAS,QAASqB,EAAUlN,KAAOiM,IAExE5H,QAAQC,KAAK,iBAAkBgH,GAG/B,IAAI0B,EAAW,GAETI,EAAWzB,OAAOC,KAAKsB,EAAUqD,IAAI/P,OACrC4K,EAAoD,GAApC8B,EAAUoD,MAAMzE,SAAS,QACzCR,EAAkD,GAArC6B,EAAUoD,MAAMzE,SAAS,SAExCwE,GAAOlS,KAAKqS,iBAEhB,IA6BIC,EAEAvL,EA/BA+K,EAAsB/C,EAAUwD,IAEhCvL,EAAW,CACX2K,cAAe,CACX7M,KAAM,IACNmC,MAAO,GAEX2K,gBAAgB,CACZ9M,KAAM,IACNmC,MAAO,IAIXgG,IACA/G,QAAQC,KAAK,mBACba,EAAS8J,eAAiB,CACtBhM,KAAM,IACNmC,MAAO,IAGXiG,IACAhH,QAAQC,KAAK,eACba,EAAS8H,aAAe,CACpBhK,KAAM,OACNmC,MAAO,IAAIyI,aAAa,CAAC,GAAK,EAAK,OAQ3C,IAAI8C,EAAoB,IAAIrO,IAmCxBoJ,EAA+C,GAAtCwB,EAAUoD,MAAMzE,SAAS,UAAqBQ,EAAaV,OAAO5M,OAAOiN,IAAoBkB,EAAUxB,OACpHA,EAAS,MAET,IAAIkF,EAAiB,IAAKtO,IAA0B,EAAG,EAAG,IAE1DqO,EAAoBA,EAAkBE,KAAKD,IACzBE,kBAAoB1D,EAEtCjI,EAASoE,UAAY,CACjBtG,KAAM,OACNmC,MAAO,IAAI9C,IAAYyO,EAAO3H,MAAMG,YAExCpE,EAASqE,UAAY,CACjBvG,KAAM,IACNmC,MAAO,GAEXF,EAAW,IAAI5C,IAAyB,CACpCoL,aAAcvC,EAAsBC,EAAeC,EAAYC,GAC/DuD,eAAgB9C,EAAwBL,EAAQJ,GAChDnG,SAAUA,EACV6L,aAAa,EAGbC,WAAY9S,KAAKqO,MAEjB0E,YAAY,IAGI,GAAjB9F,GACCuF,EAAkB/C,aACd,iBACA,IAAItL,IAA+B,IAAIuL,aAAaX,EAAUyC,MAAO,GAAG,IAE/D,GAAdtE,GACCsF,EAAkB/C,aAAa,eAC3B,IAAItL,IAA+B,IAAIuL,aAAaX,EAAUvG,MAAMwG,QAAS,GAAG,IAExFwD,EAAkB/C,aAAa,sBAC3B,IAAItL,IAA+B,IAAIuL,aAAaoC,GAAsB,GAAG,IAGjFQ,EAAY,IAAInO,IAAWqO,EAAmBzL,GAE9C/G,KAAK4D,MAAMoP,IAAIV,GAEfzD,EAASS,KAAOgD,EAChBzD,EAASE,UAAYA,EACrBF,EAAS7H,SAAWA,EACpB6H,EAAStB,OAASA,EAClBsB,EAAS5B,cAAgBA,EACzB4B,EAAS3B,WAAaA,EACtB2B,EAASI,SAAWA,EAEpBjP,KAAKsO,WAAWnB,GAAkB0B,O,8iECpbrBoE,E,WACjB,WAAYrP,EAAOsP,EAAOC,I,4FAAY,SAClCnT,KAAKoT,YAAcpT,KAAKoT,YAAY7N,KAAKvF,MAEzCA,KAAK4D,MAAQA,EACb5D,KAAKkT,MAAQA,EACblT,KAAKmT,WAAaA,EAElBnT,KAAKqT,SAAW,EAChBrT,KAAKsT,UAAY,GACjBtT,KAAKuT,e,mEAOW1B,GAChB,IAD0B,EACtB2B,EAAmB,GAEjBC,EAAI,SAACnR,EAAK4N,GAAN,OAAgB5N,EAAIoR,KAAJ,MAAApR,EAAG,EAAS,CAAC,EAAG,EAAG,GAAG2N,KAAI,SAACzN,GAAD,OAAKqP,EAAU3B,EAAM1N,SAH/C,IAIPxC,KAAKsT,UAAUrI,OAJR,IAI1B,2BAAyC,oBAA/BoG,EAA+B,KAEjCsC,EAAS,EAFwB,KAMrCF,EAAED,EALW,EAAFnC,GAMXoC,EAAED,EAAkBG,IAXE,8BAa1B3T,KAAKuT,eAAe/D,SAASI,WAAWgE,SAAS/D,MAAQ,IAAIH,aAAa8D,GAC1ExT,KAAKuT,eAAe/D,SAASI,WAAWgE,SAASjE,aAAc,EAC/D3P,KAAKuT,eAAe/D,SAASqE,0B,yCAEdC,GAEf,IAAItL,EAAQ,IAAIrE,IAAY2P,GAC5B9T,KAAKuT,eAAexM,SAASyB,MAAQA,EACrCxI,KAAKuT,eAAexM,SAAS4I,aAAc,I,kCAGlClE,GAETzL,KAAKuT,eAAexM,SAASgN,UAAYtI,EACzCzL,KAAKuT,eAAexM,SAAS4I,aAAc,I,kCAGnChB,GACR,IAAIU,EAASS,IAAS,CAClBA,SAAU,MACVC,QAAS/P,KAAKqT,SACdrD,OAAQ,QACR1L,MAAO,IAEP1D,EAASZ,KAAKsT,UAAU3E,GAEtBG,EAAeO,EAChBY,KAAI,SAACzH,EAAO0H,GAAR,MAAkB,CAACtP,EAAOsP,GAAQ1H,MACtC4H,MAAK,kBAAEC,EAAF,2BAA2BA,KAChCJ,KAAI,gCACJA,KAAI,yBAAEK,EAAF,KAAKC,EAAL,KAAQC,EAAR,iBAAoB,CAACF,EAAGC,EAAGC,EAAGF,EAAGC,EAAGC,MACxCxB,OAEL,GAAIF,EAAazM,QAAwB,EAAdrC,KAAKqT,SAG5B,OAFAnE,IAASC,MAAM,qBACf6E,MAAM,aAIVhU,KAAKuT,eAAe/D,SAASI,WAAWpH,MAAMqH,MAAQ,IAAIH,aAAaZ,GACvE9O,KAAKuT,eAAe/D,SAASI,WAAWpH,MAAMmH,aAAc,EAC5D3P,KAAKuT,eAAexM,SAAS4I,aAAc,I,oCAGjC1I,GACVjH,KAAKuT,eAAexM,SAASwE,QAAQtE,EAErCjH,KAAKuT,eAAexM,SAAS4I,aAAc,I,wCAE7BZ,EAAWuE,GACzBtT,KAAKiU,eAAelF,EAAWuE,GAC/BtT,KAAKkU,mB,uCAGLlU,KAAKwL,MAAMgE,SAASwC,UACpBhS,KAAKwL,MAAMgE,UAAW,IAAIrL,KAAuBgQ,cAC7C3G,OAAO5M,OAAOZ,KAAKoU,a,qCAYZrF,EAAWuE,EAAWe,GACjCrU,KAAKoU,SAAW,GAChBpU,KAAKsU,SAAW,GAChB,IAH8C,EAG1CzC,EAAY,GAKV4B,EAAI,SAACnR,EAAK4N,GAAN,OAAgB5N,EAAIoR,KAAJ,MAAApR,EAAG,EAAS,CAAC,EAAG,EAAG,GAAG2N,KAAI,SAACzN,GACjD,IAAI+P,EAAMxD,EAAUwD,IAAU,EAANrC,EAAQ1N,GAGhC,OAFM,GAAHA,IACC+P,GAAU,KACPA,QAZmC,IAc3Be,EAAUrI,OAdiB,IAc9C,2BAAoC,oBAA1BoG,EAA0B,KAAvBkD,EAAuB,KAMfxF,EAAUqD,GAAGf,GACZtC,EAAUqD,GAAGmC,GAC1BjI,KAAKyB,UAAW,IAGrB0F,EAAE5B,EAAW0C,GACbd,EAAE5B,EAAWR,KA1B6B,8BA8C9CrR,KAAK6R,UAAYA,EACjB7R,KAAKqP,OA3CQ,K,uCA8CVrP,KAAKuT,iBACJvT,KAAKuT,eAAe/D,SAASwC,UAC7BhS,KAAKuT,eAAexM,SAASiL,UAC7BhS,KAAKuT,eAAe/D,SAASG,aAAc,EAC3C3P,KAAKuT,eAAexM,SAAS4I,aAAc,EAC3C3P,KAAK4D,MAAMqO,OAAOjS,KAAKuT,gBACvBvT,KAAKuT,eAAiB,Q,kCAIlBxE,EAAWuE,GACnBtT,KAAKwU,iBAELxU,KAAKsT,UAAYA,EACjBtT,KAAKqT,SAAWrT,KAAKsT,UAAUrI,MAAM5I,OACrCrC,KAAKiU,eAAelF,EAAWuE,GAC/B,IAAI9D,EAAW,IAAIrL,IACf4C,EAAW,IAAI5C,IAAyB,CACxCsQ,cAAc,EACdC,SAAUvQ,IACV0O,aAAY,EACZrK,MAAO,KACP+C,QAAQ,GAAKwI,UAAU,IAE3BvE,EAASmF,aAAc,WAAY,IAAIxQ,IAA8BnE,KAAK6R,UAAW,IAGrFrC,EAASqE,wBAET,IAAIrI,EAAQ,IAAIrH,IAAYqL,EAAUzI,GACtC/G,KAAKuT,eAAiB/H,EACtBxL,KAAK4D,MAAMoP,IAAKxH,Q,sMCxLxB,IAAMoJ,EAAQ,CACZ,KAAU,GACV,GAAU,GACV,MAAW,GACX,KAAU,GACV,MAAW,GACX,IAAW,EACX,OAAW,IAGQC,E,WACnB,WAAYC,GAAY,Y,4FAAA,SACtB9U,KAAK8U,WAAaA,GAAcjS,SAChC7C,KAAK+U,SAAW,GAGhB/U,KAAK8U,WAAWzP,iBAAiB,WAAW,SAACM,GAAD,OAAW,EAAKqP,YAAYrP,MAAQ,GAChF3F,KAAK8U,WAAWzP,iBAAiB,SAAS,SAACM,GAAD,OAAW,EAAKqP,YAAYrP,MAAQ,GAG9E1D,OAAOoD,iBAAiB,QAAQ,kBAAM,EAAK4P,UAAQ,G,yDAG3C,WACRjV,KAAK8U,WAAW1M,oBAAoB,WAAW,SAACzC,GAAD,OAAW,EAAKqP,YAAYrP,MAAQ,GACnF3F,KAAK8U,WAAW1M,oBAAoB,SAAS,SAACzC,GAAD,OAAW,EAAKqP,YAAYrP,MAAQ,GAGjF1D,OAAOmG,oBAAoB,QAAQ,kBAAM,EAAK6M,UAAQ,K,+BAItD,IAAI,IAAMtG,KAAQ3O,KAAK+U,SACrB/U,KAAK+U,SAASpG,IAAQ,I,kCAGdhJ,GAKV,IAAMuP,EAAUvP,EAAMuP,QACtBlV,KAAK+U,SAASG,GAA0B,YAAfvP,EAAMb,O,8BAGzBqQ,GAEN,IADA,IAAM1H,EAAO0H,EAAQhT,MAAM,KACnBK,EAAI,EAAGA,EAAIiL,EAAKpL,OAAQG,IAAK,CACnC,IAAMuP,EAAMtE,EAAKjL,GACb4S,GAAU,EAMd,GAJEA,GADqC,GAApC5H,OAAOC,KAAKmH,GAAOS,QAAQtD,GAClB/R,KAAK+U,SAASH,EAAM7C,IAEpB/R,KAAK+U,SAAShD,EAAIuD,cAAc7S,WAAW,KAEnD2S,EACF,OAAO,EAGX,OAAO,I,mCAGIzP,EAAOwP,GAMlB,IALA,IAAMI,EAAUX,EACVY,EAAYhI,OAAOC,KAAK8H,GACxB9H,EAAO0H,EAAQhT,MAAM,KAGnBK,EAAI,EAAGA,EAAIiL,EAAKpL,OAAQG,IAAK,CACnC,IAAMuP,EAAMtE,EAAKjL,GACb4S,GAAU,EAcd,GAbW,UAARrD,EACDqD,IAAUzP,EAAM8P,SACA,SAAR1D,EACRqD,IAAUzP,EAAM+P,QACA,QAAR3D,EACRqD,IAAUzP,EAAMgQ,OACA,SAAR5D,EACRqD,IAAUzP,EAAMiQ,SACoB,IAA5BJ,EAAUH,QAAQtD,GAC1BqD,EAAUzP,EAAMuP,UAAYK,EAAQxD,GAC5BpM,EAAMuP,UAAYnD,EAAIuD,cAAc7S,WAAW,KACvD2S,GAAU,IAERA,EACF,OAAO,EAGX,OAAO,O,0MCnFUS,E,WACjB,WAAY9R,EAAQE,EAAU2O,EAAQkD,EAAQC,GAAc,Y,4FAAA,SAExD/V,KAAK+D,OAASA,EACd/D,KAAK+V,aAAeA,EACpB/V,KAAK8V,OAASA,EACd9V,KAAKgW,QAAU,KAGfhW,KAAKiW,SAAW,IAAIpB,EAQpB7U,KAAKkW,cAAgBlW,KAAKkW,cAAc3Q,KAAKvF,MAE7CA,KAAKiW,SAASnB,WAAWzP,iBAAiB,WAAW,SAACM,GAAD,OAAW,EAAKuQ,cAAcvQ,MAOnF3F,KAAKiE,SAAWA,E,6DAEN0B,GAAM,WAEZoM,GADSpM,EAAMwQ,OACTxQ,EAAMoM,KAIhB,OAHmBlP,SAAS6C,eAAe,uBAEtBqD,EAAE,mBACfgJ,EAAIqE,eACR,IAAK,IACDlH,IAASmH,QAAQ,gBACjBrW,KAAK8V,OAAOQ,QAAS,EACrBtW,KAAKiE,SAASsS,QAAU,UACxBrQ,QAAQC,KAAK,oBACb,MAEJ,IAAK,IACD+I,IAASmH,QAAQ,eACjBrW,KAAK8V,OAAOQ,QAAS,EACrBtW,KAAKiE,SAASsS,QAAU,SACxBrQ,QAAQC,KAAK,0BACb,MACJ,IAAK,IACD+I,IAASmH,QAAQ,mBACjBrW,KAAK8V,OAAOQ,QAAS,EACrBtW,KAAKiE,SAASsS,QAAU,aACxB,MAEJ,IAAK,IACD1T,SAAS6C,eAAe,kBAAkBuB,MAAQhF,OAAOuE,WACzD3D,SAAS6C,eAAe,mBAAmBuB,MAAQhF,OAAOwE,YAE1DzG,KAAK+V,aAAchE,EAAI,WAE3B,IAAK,IAC4B,WAAzB/R,KAAKiE,SAASsS,SACdvW,KAAK+V,aAAahE,EAAK,cAC3B,MAGJ,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IAE6B,UAAzB/R,KAAKiE,SAASsS,SAA6B,KAALxE,GACvC7C,IAASsH,QAAQ,8CACb,WACI,EAAKT,aAAahE,EAAK,kBAIN,WAAzB/R,KAAKiE,SAASsS,SACdvW,KAAK+V,aAAahE,EAAK,QAG3B,MAEJ,IAAK,IAC4B,UAAzB/R,KAAKiE,SAASsS,SACdrH,IAASmH,QAAQ,4BACjBrW,KAAK+V,aAAchE,EAAI,mB,0pCClF3C,SAAS0E,GAAe3J,EAAQ4J,GAE5B,IADA,IAAIC,EAAe,GACXnU,EAAE,EAAGA,EAAEkU,EAAKrU,OAAQG,IAAI,CAE5BmU,GADU,kBAAoBD,EAAKlU,GAAK,KAAOkU,EAAKlU,GAAK,YAIzC,IAAhBmU,IAAoB7J,EAAOgI,WAAW8B,SAAS,GAAGC,UAAYF,G,IAIjDG,G,WACjB,WACIC,EACAnT,EAAO7D,EACPiE,EACAgT,EAAQC,EACRrE,EACA3O,I,4FAAU,SACV,IAAMiT,EAAM,IAAIC,IAAQ,CAACC,WAAU,EAAOvV,KAAKkV,IAC/C/W,KAAKkX,IAAMA,EAGXrU,SAAS6C,eAAT,gBAAiCqR,IAAgBM,YAAYH,EAAIpC,YACjE,IAAMxP,EAASvF,EAASuF,OAON4R,EAAII,UAAU,SAEpBC,SAAS3E,EAAOhP,MAAO,SAAS/B,KAAK,SAAS2V,UAAS,SAAChP,GAChE5E,EAAM6E,WAAa,IAAItE,IAAYqE,GACnClD,OAKJ,IAAImS,EAAcP,EAAII,UAAU,SAChCtX,KAAK0X,cAAgBD,EAAYzE,IAAI/O,EAAU,gBAAiBA,EAASyT,eACpE7V,KAAK,YACL2V,UAAS,SAASvQ,GACf+P,EAAOW,YAAY1Q,MAO3BwQ,EAAYzE,IALE,CACVzF,OAAS,CACL,KAAO,KAGU,SAAUM,GAC9BhM,KAAK,UACL2V,UAAS,SAASvQ,GACf+P,EAAOY,aAAa3Q,GACpB3B,OAERmS,EAAYzE,IAAKJ,EAAO3H,MAAO,QAASuM,UAAU,SAAWvQ,GACzD,cAA6BuG,OAAOkB,QAAQsI,EAAO/L,OAAnD,eAA0D,4BACjD4M,QAAQ5Q,EAGjB2L,EAAO3H,MAAME,KAAOlE,EACpB3B,OAGJmS,EAAYF,SAAS3E,EAAO3H,MAAO,SAASpJ,KAAK,SAAS2V,UAAS,SAAChP,GAChEwO,EAAOc,YAAYtP,GACnBlD,OAEJtF,KAAK+X,UAAYN,EAAYzE,IAAI/O,EAAU,eAAgBA,EAASoQ,cAC/DxS,KAAK,cACL2V,UAAS,SAASvQ,GACf+P,EAAOgB,YAAY/Q,GAEnB3B,OAERmS,EAAYzE,IAAIJ,EAAO3H,MAAO,QAAS,IAAM,GAAI,KAAMpJ,KAAK,SAAS2V,UAAS,SAACvQ,GAC3E+P,EAAOiB,YAAYhR,GAEnB3B,OAGJmS,EAAYF,SAAS3E,EAAO3H,MAAO,aAAapJ,KAAK,cAAc2V,UAAS,SAAChP,GACzEwO,EAAOkB,gBAAgB1P,GACvBlD,OAEJmS,EAAYzE,IAAIJ,EAAO3H,MAAO,YAAa,EAAK,EAAG,KAAMpJ,KAAK,cAAc2V,UAAS,SAACvQ,GAClF+P,EAAOmB,gBAAgBlR,GACvB3B,OAGJmS,EAAYzE,IAAIJ,EAAO3H,MAAO,UAAW,EAAG,GAAGpJ,KAAK,WAAW2V,UAAS,SAACvQ,GACrE+P,EAAOoB,cAAcnR,GAErB3B,OAIJtF,KAAKqY,UAAYZ,EAAYzE,IAAI/O,EAAU,eAAgBA,EAASoQ,cAC/DxS,KAAK,kBACL2V,UAAS,SAASvQ,GACf+P,EAAOsB,YAAYrR,MAE3BjH,KAAKuY,WAAad,EAAYzE,IAAI/O,EAAU,eAAgBA,EAASoQ,cAChExS,KAAK,eACL2V,UAAS,SAASvQ,GACf+P,EAAOwB,aAAavR,MAK5BjH,KAAKyX,YAAcA,EAGnB,IAAIgB,EAAcvB,EAAII,UAAU,SAEhCmB,EAAYzF,IAAKJ,EAAOpH,MAAO,QAASgM,UAAU,SAAWvQ,GAEzD2L,EAAOpH,MAAML,KAAOlE,EACpB3B,OAMJmT,EAAYzF,IAAIJ,EAAOpH,MAAO,UAAW,EAAG,GAAG3J,KAAK,WAAW2V,UAAS,SAACvQ,GACrEgQ,EAAOmB,cAAcnR,GAErB3B,OAIPmT,EAAYzF,IAAIJ,EAAOpH,MAAO,QAAS,EAAK,EAAG,KAAM3J,KAAK,SAAS2V,UAAS,SAACvQ,GACtEgQ,EAAOyB,YAAYzR,GACnB3B,OAGJ,IAAIqT,EAAY,CAAChK,KAAK,GAAIiK,MAAM,IAEhC5Y,KAAK6Y,eAAiBJ,EAAYzF,IAAI2F,EAAW,QAASA,EAAUhK,MAC/D9M,KAAK,mBACL2V,UAAS,SAASvQ,GACfgQ,EAAOuB,aAAavR,MAO5BwR,EAAYlB,SAAS3E,EAAOpH,MAAO,SAAS3J,KAAK,SAAS2V,UAAS,SAAChP,GAChEyO,EAAO6B,mBAAmBtQ,GAC1BlD,OAEJmT,EAAYzF,IAAIJ,EAAOpH,MAAO,UAAW,EAAG,GAAG3J,KAAK,WAAW2V,UAAS,SAACvQ,GACrEgQ,EAAOmB,cAAcnR,MA2CzB,IAAI8R,EAAe7B,EAAII,UAAU,UACjCyB,EAAa/F,IAAKJ,EAAOtM,UAAW,WAAY,GAAK,GAAIkR,UAAU,SAAWvQ,GAE1ElH,EAASiZ,oBAAsB1M,KAAK2M,IAAKhS,EAAO,GAChD3B,OAGJyT,EAAa/F,IAAKJ,EAAOtM,UAAW,YAAa,EAAK,GAAMkR,UAAU,SAAWvQ,GAE7ElH,EAASuG,UAAU+D,UAAY6O,OAAQjS,GACvC3B,OAIJyT,EAAa/F,IAAKJ,EAAOtM,UAAW,WAAY,EAAK,IAAOkR,UAAU,SAAWvQ,GAE7ElH,EAASuG,UAAU8D,SAAW8O,OAAQjS,GACtC3B,OAIJyT,EAAa/F,IAAKJ,EAAOtM,UAAW,SAAU,EAAK,GAAM6S,KAAM,KAAO3B,UAAU,SAAWvQ,GAEvFlH,EAASuG,UAAUgE,OAAS4O,OAAQjS,GACpC3B,OAsBJvF,EAASmF,a,mEAIOtE,GAChBA,EAAOwY,QAAQ,IACf3C,GAAezW,KAAK0X,cAAgB9W,K,0CAEpBA,GAChBA,EAAOwY,QAAQ,IACfxY,EAASA,EAAOyY,QAAO,SAAAC,GAAC,MAAQ,OAALA,KAC3B7C,GAAezW,KAAKuY,WAAa3X,GACjC6V,GAAezW,KAAKqY,UAAYzX,GAChC6V,GAAezW,KAAK+X,UAAYnX,EAAOyY,QAAO,SAAAC,GAAC,MAAM,SAAHA,Q,0CAElC1Y,GAChBA,EAAOwY,QAAQ,IACf3C,GAAezW,KAAK6Y,eAAiBjY,GACrC6V,GAAezW,KAAKuZ,cAAgB3Y,Q,4SC/PtB4Y,G,WAQlB,WACIzC,EACAnE,EACA6G,GAWF,IAVEpL,EAUF,wDATE5K,IASF,yDAREC,IAQF,yDAPEgW,IAOF,yDANE1V,EAMF,uDANS,CACH4H,IAAK,GACLD,KAAM,EACNE,IAAK,IACLtE,OAAQ,GAEd,WACEvH,KAAK4S,OAASA,EACd5S,KAAKqO,MAAQA,EACbrO,KAAK0Z,UAAYA,EACjB1Z,KAAKyD,eAAiBA,EACtBzD,KAAK0D,SAAWA,EAChB1D,KAAK+W,aAAeA,EACpB/W,KAAK+D,OAASlB,SAAS6C,eAAT,UAA2BqR,IACzC/W,KAAK8D,UAAYjB,SAAS6C,eAAT,mBAAoCqR,IAEjD/W,KAAKgE,OADNqK,EACe,IAAIlK,IACd,GAAI,EAAG,GAAI,EAAGyO,EAAO5O,OAAO2H,KAAMiH,EAAO5O,OAAO6H,KAGtC,IAAI1H,IACdH,EAAO4H,IAAK5H,EAAOuD,OAAQ,EAAGvD,EAAO6H,KAG7C7L,KAAK4D,MAAQ,IAAIO,IAEjBnE,KAAKD,SACLC,KAAK2Z,MACL3Z,KAAKyZ,sBAAwBA,E,sDAIb,IAAfvV,EAAe,wDAChBlE,KAAK2Z,MAAQ,CACTpD,QAAS,SACTxM,UAAU,EACV6P,WAAW,EACXhR,kBAAkB,EAClBC,aAAa,EACbgR,QAAS,GACTnC,cAAc,GACdoC,WAAW,EACXzF,aAAc,IAIApS,OAAOuE,WAAavE,OAAOwE,YAC7CzG,KAAK2Z,MAAMlS,eAAiBxF,OAAOuE,WAAavE,OAAOwE,YAEvDzG,KAAK4D,MAAMoP,IAAIhT,KAAKgE,QAEpBhE,KAAK4D,MAAM6E,WAAa,IAAItE,IAAYnE,KAAK4S,OAAOhP,MAAM4E,OAE1DxI,KAAKiL,MAAQ,IAAImD,EAAMpO,KAAK4D,MAAO5D,KAAKqO,OACxCrO,KAAKwL,MAAQ,IAAIyH,EAAMjT,KAAK4D,MAAO,EAAG,GAGtC5D,KAAK6D,SAAW,IAAIkW,IAAc/Z,KAAKgE,OAAQhE,KAAK+D,QAEpD/D,KAAK6D,SAASiJ,OAAOkN,IAAI,EAAG,EAAG,GAC/Bha,KAAK6D,SAASoW,YAAW,EACzBja,KAAK6D,SAASqW,oBAAqB,EAEhCla,KAAKqO,QAEJrO,KAAK6D,SAASsW,cAAa,GAO/BjU,QAAQkU,MAAM,eACdpa,KAAKD,SAAW,IAAIyD,EAChBxD,KAAKyD,eACLzD,KAAK0D,SACL1D,KAAK0Z,UACL1Z,KAAK4D,MAAO5D,KAAK6D,SAAU7D,KAAK8D,UAAW9D,KAAK+D,OAAQ/D,KAAKgE,OAAQhE,KAAK2Z,MAC1EzV,GACJgC,QAAQmU,WAEJra,KAAK4S,OAAO/I,gBACZ7J,KAAK8V,OAAS,IAAIgB,GACd9W,KAAK+W,aACL/W,KAAK4D,MACL5D,KAAKD,SACLC,KAAKgE,OACLhE,KAAKiL,MACLjL,KAAKwL,MACLxL,KAAK4S,OACL5S,KAAK2Z,QAET3Z,KAAK4S,OAAO9I,cACZ9J,KAAKsa,oBAAsB,IAAIzF,EAC3B7U,KAAK+D,OACL/D,KAAK2Z,MACL3Z,KAAK4S,OACL5S,KAAK8V,OAAOoB,IACZlX,KAAKyZ,0B,mCAgBb,IAAI7F,EAAW5T,KAAKwL,MAAM+H,eAAe/D,SAAS+K,eAAeC,OACjExa,KAAKgE,OAAO4P,SAAS7G,EAAI,EAAE/M,KAAKwL,MAAM+H,eAAe/D,SAAS+K,eAAejQ,OAE7EtK,KAAKgE,OAAOyW,OAAO7G,GACnB5T,KAAKgE,OAAO+D,yBACZ/H,KAAKD,SAASuF,W,oCAMdtF,KAAKiL,MAAMoH,iBACXrS,KAAKwL,MAAMgJ,mB,6BASR/I,EAAOiP,EAAQC,GAClBA,EAAeA,IAAgB,EAC/B,IAAMC,EAAM5a,KAAKD,SAAS+I,OAAO2C,EAAOiP,EAAQC,GAChD3a,KAAK4a,IAAMA,I,mCAOX5a,KAAKD,SAAS8a,Y,iOC5KDC,G,WACjB,WAAYpR,EAASqR,I,4FAAkB,SACnC/a,KAAK0J,QAAUA,EACf1J,KAAKgb,GAAKC,KAAGC,QAAH,iBAAqBxR,EAArB,MAMV1J,KAAKgb,GAAGG,GAAG,cAAa,SAACxV,GACrBuJ,IAASkM,QAAQ,wBAGrBpb,KAAKgb,GAAGG,GAAG,qBAAoB,SAASE,GACpCN,EAAiBM,MAErBrb,KAAKgb,GAAGM,KAAK,WAAY,CAAEC,KAAM,cAEjCvb,KAAKgb,GAAGM,KAAK,oBACbtb,KAAKwb,SAAWxb,KAAKwb,SAASjW,KAAKvF,M,wDAInC,IAAMyb,EAAOzb,KAAKgb,GAAGU,aAAe1b,KAAKgb,GAAGW,KAM5C,OALKF,IACDvM,IAASC,MAAM,qBACfjJ,QAAQiJ,MAAM,oBACdnP,KAAKgb,GAAK,IAAIY,UAAJ,eAAsBhJ,EAAOlJ,QAA7B,OAEP+R,I,iCAKPzb,KAAKgb,GAAGM,KAAK,c,kCAELO,EAAQC,GAChB9b,KAAKgb,GAAGM,KAAK,kBAAmB,CAAC,OAASO,EAAQ,KAAOC,M,kCAGjDC,GAER,GADA7V,QAAQC,KAAK,cAAe4V,GACvB/b,KAAKgc,SAAV,CACA,IAAM3F,EAAU,CACZvR,KAAM,cACNqB,KAAM,CAAC,QAAW4V,IAEtB/b,KAAKgb,GAAGiB,KAAKC,KAAKC,UAAU9F,O,oCAI5BnQ,QAAQC,KAAK,gBACRnG,KAAKgc,UAIVhc,KAAKgb,GAAGiB,KAAKC,KAAKC,UAHF,CACZrX,KAAM,mB,kCAQVoB,QAAQC,KAAK,cACRnG,KAAKgc,UAIVhc,KAAKgb,GAAGiB,KAAKC,KAAKC,UAHF,CACZrX,KAAM,oB,kCC9DhB8N,EAAOjJ,OAAQ,EAyIjB,IAAMyS,GAAcna,OAAOoa,SAASC,OAC9BC,GAAY,IAAIC,gBAAgBJ,IAEtClW,QAAQC,KAAKiW,IACb,IAAM3Y,KAAiB8Y,GAAUE,IAAI,gBAA8C,KAA9BF,GAAUG,IAAI,eAC7DhZ,IAAW6Y,GAAUE,IAAI,UAAkC,KAAxBF,GAAUG,IAAI,SACjDrO,KAAQkO,GAAUE,IAAI,UAAkC,KAAxBF,GAAUG,IAAI,SAC9ChT,GAAU6S,GAAUE,IAAI,WAAYF,GAAUG,IAAI,WAAY,iBAC9DhD,KAAY6C,GAAUE,IAAI,UAAkC,KAAxBF,GAAUG,IAAI,SAExD9J,EAAO/I,eAAgB,EAEvB,IAAM8S,GAAW,IAAInD,GACjB,cACA5G,GApJJ,SAA+Bb,EAAK6K,GAE5B,OAAQA,GACJ,IAAK,UACD7T,EAAE,mBAAmBC,MAAM,QAC/B,MACA,IAAK,aAcL,IAAK,OAYD,MACJ,IAAK,YACD6T,GAAeC,YAEf,MAEJ,IAAK,cACDD,GAAeE,iBA+G3B1O,GACA5K,GACAC,GACAgW,IAEJzX,OAAO+a,YAAcL,GAErBzW,QAAQkU,MAAM,oBAEdlU,QAAQC,KAAK,WAAYuD,IAEzB,IAAImT,GAAiB,IAAI/B,GAASpR,IAnHlC,SAA0B2M,GAEtB,OAAQA,EAAO,MACb,IAAK,gBACH4G,cAAcC,IAGdhX,QAAQkU,MAAM,YACdlU,QAAQ4V,KAAK,iBAEb5V,QAAQkU,MAAM,eACduC,GAASnR,MAAM4H,YACbiD,EAAQpL,MACRoL,EAAQ7K,MACR6K,EAAQhC,cAEVnO,QAAQmU,WACRnU,QAAQiX,QAAQ,iBAEhBjX,QAAQkU,MAAM,eACdlU,QAAQ4V,KAAK,iBACba,GAAS1R,MAAMmS,YAAY/G,EAAQpL,OAAO,GAC1C/E,QAAQiX,QAAQ,iBAChBjX,QAAQmU,WACJsC,GAAShD,MAAMC,YACjB+C,GAAS/C,WAAY,EACrB+C,GAASU,aACTJ,cAAcC,KAGhBP,GAAS1R,MAAMqS,aAMfX,GAAS7G,OAAOyH,oBAAoBlH,EAAQpL,MAAMkH,OAClDwK,GAAS7G,OAAO0H,oBACdhQ,OAAOC,KAAKkP,GAAS1R,MAAMqD,aAI7BpI,QAAQmU,WAER,MAEF,IAAK,WACHsC,GAAS1R,MAAMmS,YAAY/G,EAAQpL,OAAO,GACtC0R,GAAShD,MAAMC,YACjB+C,GAAS/C,WAAY,EACrB+C,GAASU,aACTJ,cAAcC,KAGhB,MACF,IAAK,cAMH,MAEF,IAAK,YACHP,GAAS1R,MAAMwS,oBAAoBpH,EAAQlQ,KAAKoM,KAChDoK,GAASnR,MAAMiS,oBAAoBpH,EAAQlQ,KAAKoM,KAChDoK,GAAS5c,SAASuF,SAClB,MAEF,IAAK,mBACH,IAAMxD,EAAU6a,GAAS5c,SAASyF,eAChC6Q,EAAO,MACPA,EAAO,OACPA,EAAO,cAETwG,GAAezT,YAAYtH,EAASuU,EAAO,MAC3C,MACF,IAAK,mBACHsG,GAAS1R,MAAMmE,aAAaiH,EAAQhH,OAAQ,QAC5CsN,GAAS5c,SAASuF,aAqC1BqX,GAASe,KAAKb,IACd,IAAMK,GAAmBS,aAAY,WACjCd,GAAerB,aAChB,KAEHtV,QAAQmU,a","file":"0.app.js","sourcesContent":["// Local vars for rStats\nlet rS, bS, glS, tS;\n\nexport default class Stats {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n\n  setUp() {\n    bS = new BrowserStats();\n    glS = new glStats();\n    tS = new threeStats(this.renderer);\n\n    rS = new rStats({\n      CSSPath: './css/',\n      userTimingAPI: true,\n      values: {\n        frame: { caption: 'Total frame time (ms)', over: 16, average: true, avgMs: 100 },\n        fps: { caption: 'Framerate (FPS)', below: 30 },\n        calls: { caption: 'Calls (three.js)', over: 3000 },\n        raf: { caption: 'Time since last rAF (ms)', average: true, avgMs: 100 },\n        rstats: { caption: 'rStats update (ms)', average: true, avgMs: 100 },\n        texture: { caption: 'GenTex', average: true, avgMs: 100 }\n      },\n      groups: [\n        { caption: 'Framerate', values: ['fps', 'raf'] },\n        { caption: 'Frame Budget', values: ['frame', 'texture', 'setup', 'render'] }\n      ],\n      fractions: [\n        { base: 'frame', steps: ['texture', 'setup', 'render'] }\n      ],\n      plugins: [bS, tS, glS]\n    });\n  };\n\n  static start() {\n    rS('frame').start();\n    glS.start();\n\n    rS('rAF').tick();\n    rS('FPS').frame();\n\n    rS('render').start();\n  };\n\n  static end() {\n    rS('render').end(); // render finished\n    rS('frame').end(); // frame finished\n\n    // Local rStats update\n    rS('rStats').start();\n    rS().update();\n    rS('rStats').end();\n  };\n}\n","import * as THREE from 'three';\n\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\nimport { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';\n\nimport {BloomPass} from 'three/examples/jsm/postprocessing/BloomPass.js';\nimport { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';\nimport { FXAAShader } from 'three/examples/jsm/shaders/FXAAShader.js';\n\nimport alertify from 'alertifyjs';\n\nimport Stats from './../../helpers/stats';\n\n\n\n/**\n * Random select a element of a given array\n * @param  {array} arr -\n * @return {Object} A random choiced element of the given array\n */\nfunction dataURIToBlob( dataURI ) {\n    const binStr = window.atob( dataURI.split( ',' )[1] );\n    const len = binStr.length;\n    const arr = new Uint8Array( len );\n    for ( let i = 0; i < len; i++ ) {\n        arr[i] = binStr.charCodeAt( i );\n    }\n    return new window.Blob( [arr] );\n}\n\n/**\n * Random select a element of a given array\n * @param  {array} arr -\n * @return {Object} A random choiced element of the given array\n */\nfunction saveDataURI( name, dataURI ) {\n    const blob = dataURIToBlob( dataURI );\n\n    // force download\n    const link = document.createElement( 'a' );\n    link.download = name;\n    link.href = window.URL.createObjectURL( blob );\n    link.onclick = () => {\n        window.setTimeout( () => {\n            window.URL.revokeObjectURL( blob );\n            link.removeAttribute( 'href' );\n        }, 500 );\n\n    };\n    link.click();\n}\n\n\n/**\n * Random select a element of a given array\n * @param  {array} arr -\n * @return {Object} A random choiced element of the given array\n */\n\nfunction defaultFileName (ext) {\n    const str = `${new Date().toLocaleDateString()} at ${new Date().toLocaleTimeString()}${ext}`;\n    return str.replace(/\\//g, '-').replace(/:/g, '.');\n}\n\n\nexport default class Renderer {\n    constructor(\n        useHighQuality,\n        useBloom,\n        useStats,\n        scene, controls, container, canvas, camera, appState , dataPool) {\n        this.scene = scene;\n        this.controls = controls;\n        this.canvas = canvas;\n        this.container = container;\n        this.camera = camera\n        this.appState = appState\n        this.dataPool = dataPool;\n\n        //renderer.toneMapping = THREE.ReinhardToneMapping;\n        this.useHighQuality = useHighQuality;\n        this.useBloom = useBloom;\n        this.useStats = useStats;\n        // Create WebGL render\n        this.renderer = new THREE.WebGLRenderer(\n            {\n                canvas: canvas,\n                antialias: useHighQuality,\n                preserveDrawingBuffer: true,\n                alpha:true\n            }\n        );\n        this.renderer.autoClear = false;\n        if(this.useStats) {\n            this.stats = new Stats(this.renderer);\n            this.stats.setUp();\n        }\n\n        this.renderer.setPixelRatio(window.devicePixelRatio); // For retina\n\n\n        this.renderer.shadowMap.enabled = false;\n        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n\n        // Initial size update set to canvas canvas\n        //\n        if (useHighQuality || useBloom){\n            this.initComposer()\n        }\n        if (useBloom){\n            this.initBloomComposer()\n        }\n        if (useHighQuality){\n            this.initFXAAComposer()\n        }\n\n\n\n        this.updateSize(this.canvas.offsetWidth,this.canvas.offsetHeight);\n        // Listeners\n        document.addEventListener('DOMContentLoaded', () => this.updateSize(), false);\n        window.addEventListener('resize', () => this.updateSize(), false);\n\n        //\n        this.controls.addEventListener('change', ()=>this.render());\n\n        this.render = this.render.bind(this)\n        this.updateSize = this.updateSize.bind(this)\n\n        this.takeScreenshot = this.takeScreenshot.bind(this)\n        const btnSave = document.getElementById(\"btnSaveImage\");\n        if(btnSave)\n            btnSave.addEventListener(\"click\",  event=>this.takeScreenshotModal())\n\n    }\n    initComposer(){\n        this.composer = new EffectComposer( this.renderer );\n        let renderPass = new RenderPass( this.scene, this.camera );\n        this.composer.addPass( renderPass );\n\n    }\n    initBloomComposer(){\n        console.info('Init Bloom');\n\n        this.renderer.toneMapping = THREE.ReinhardToneMapping;\n        const bloomPass = new BloomPass(\n            1,    // strength\n            25,   // kernel size\n            4,    // sigma ?\n            256,  // blur render target resolution\n        );\n        const strength = 1;\n        const radius = 2;\n        const threshold = 0;\n        this.bloomPass = new UnrealBloomPass(\n            new THREE.Vector2( window.innerWidth, window.innerHeight ),\n            strength, radius, threshold );\n        this.composer.addPass(this.bloomPass);\n\n    }\n    initFXAAComposer(){\n        console.info('Init FXAA');\n\n        let fxaaPass = new ShaderPass( FXAAShader );\n\n        const pixelRatio = this.renderer.getPixelRatio();\n\n        fxaaPass.material.uniforms[ 'resolution' ].value.x = 1 / ( this.canvas.offsetWidth * pixelRatio );\n        fxaaPass.material.uniforms[ 'resolution' ].value.y = 1 / ( this.canvas.offsetHeight * pixelRatio );\n        this.fxaaPass = fxaaPass\n        this.composer.addPass( fxaaPass );\n\n    }\n    setCameraAspect(widthRender, heightRender, keepPos=true) {\n\n        const canvas = this.canvas;\n        //const widthRender = window.innerWidth\n        //const heightRender = window.innerHeight\n        //\n        if(keepPos){\n            const aspect = widthRender / heightRender\n            const change = this.appState.originalAspect/aspect\n\n            const newSize = 1 * change;\n            this.camera.left = -aspect * newSize / 2;\n            this.camera.right = aspect * newSize  / 2;\n            this.camera.top = newSize / 2;\n            this.camera.bottom = -newSize / 2;\n        }\n        this.camera.aspect = widthRender / heightRender;\n\n        this.camera.updateProjectionMatrix();\n    }\n    updateSize(widthRender, heightRender, keepPos=true) { //if (this.appState.takingScreenshot) return;\n        widthRender = widthRender || this.container.clientWidth\n        heightRender= heightRender ||this.container.clientHeight\n\n        this.setCameraAspect(widthRender, heightRender, keepPos)\n\n        if (this.useHighQuality || this.useBloom){\n\n            this.renderer.setSize(widthRender, heightRender, );\n            this.composer.setSize( widthRender, heightRender );\n        }else{\n            this.renderer.setSize(widthRender, heightRender, );\n        }\n\n\n        if (this.useHighQuality){\n            const pixelRatio = this.renderer.getPixelRatio();\n            this.fxaaPass.material.uniforms[ 'resolution' ].value.x = 1 / ( widthRender * pixelRatio );\n            this.fxaaPass.material.uniforms[ 'resolution' ].value.y = 1 / ( heightRender * pixelRatio );\n        }\n        //this.appState.originalAspect  = aspect\n        this.render()\n        //const pixelRatio = window.devicePixelRatio;\n        //const width  = widthRender  * pixelRatio | 0;\n        //const height = heightRender * pixelRatio | 0;\n        //const needResize = canvas.width !== width || canvas.height !== height;\n\n        //if (needResize) {\n\n        //this.renderer.setSize(width, height, );\n        //this.camera.aspect = widthRender / heightRender;\n        //this.camera.updateProjectionMatrix();\n        //}\n        //this.camera.aspect = window.innerWidth / window.innerHeight;\n        //this.camera.updateProjectionMatrix();\n\n        //this.renderer.setSize( window.innerWidth, window.innerHeight );\n\n        //this.camera.aspect = this.canvas.clientWidth / this.canvas.clientHeight;\n        //this.camera.updateProjectionMatrix();\n        //if (resizeRendererToDisplaySize(renderer)) {\n        //this.camera.aspect = this.canvas.clientWidth / this.canvas.clientHeight;\n        //this. camera.updateProjectionMatrix();\n\n        ////}\n        //this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);\n\n    }\n\n    render() {\n        // Renders scene to canvas target\n        // this.pickHelper.pick( scene, camera, 0)\n\n        if(this.useStats)\n            Stats.start();\n\n        //this.controls.update();\n        //\n        if (this.useHighQuality || this.useBloom){\n\n            //this.renderer.render(this.scene, this.camera);\n            this.composer.render();\n        }else{\n            this.renderer.render(this.scene, this.camera);\n        }\n        if(this.useStats)\n            Stats.end();\n\n\n    }\n    delete(){\n        this.render = ()=>0;\n        document.removeEventListener('DOMContentLoaded', () => this.updateSize(), false);\n        window.removeEventListener('resize', () => this.updateSize(), false);\n        const btnSave = document.getElementById(\"btnSaveImage\");\n        if(btnSave)\n            btnSave.removeEventListener(\"click\",  event=>this.takeScreenshot())\n\n    }\n    stop(){\n        //const dataURI = this.getURI(widthImage, heightImage, saveWithTransparency);\n        this.delete()\n    }\n    getURI(widthImage, heightImage, saveWithTransparency){\n        widthImage = widthImage || this.container.clientWidth\n        heightImage= heightImage ||this.container.clientHeight\n\n\n        this.setCameraAspect(widthImage, heightImage, false)\n        // set camera and renderer to desired screenshot dimension\n        //this.camera.aspect = widthImage / heightImage;\n        //this.camera.updateProjectionMatrix();\n\n        const color = this.scene.background;\n        if(saveWithTransparency){\n            this.renderer.setClearColor( 0x000000, 0 );\n            this.scene.background = null;\n        }\n        this.renderer.setSize(  widthImage, heightImage );\n\n        //this.renderer.render( this.scene, this.camera, null, false );\n\n        this.composer.setSize( widthImage, heightImage );\n        this.composer.render();\n\n        const dataURI = this.canvas.toDataURL( 'image/png', 1.0 );\n\n        if(saveWithTransparency)\n            this.scene.background = color;\n        this.appState.takingScreenshot = false\n\n        this.updateSize();\n\n        return dataURI\n    }\n    takeScreenshot(widthImage, heightImage, saveWithTransparency){\n        this.appState.takingScreenshot = true\n        this.appState.stopChanges = true\n\n        const DataURI = this.getURI(widthImage, heightImage, saveWithTransparency);\n        return DataURI\n    }\n    takeScreenshotModal(){\n\n        $('#saveImageModal').modal(\"hide\")\n        this.appState.takingScreenshot = true\n        this.appState.stopChanges = true\n        const widthImage = parseInt(document.getElementById(\"widthSaveImage\").value)\n        const heightImage = parseInt(document.getElementById(\"heightSaveImage\").value)\n\n        const saveWithTransparency = document.getElementById(\"saveWithTransparency\").checked\n\n        const send2server = document.getElementById(\"send2server\").checked;\n\n        const DataURI = this.getURI(widthImage, heightImage, saveWithTransparency);\n        if (send2server && this.dataPool){\n            this.dataPool.send2server(DataURI)\n        }else{\n            saveDataURI(defaultFileName(\".png\"), DataURI);\n        }\n    }\n}\n","\nexport default {\n    address: \"127.0.0.1:6688\" ,\n    scene: {\n        color: 0x000,\n        //color: 0xffffff\n    },\n    isDev: true,\n    render:{\n        antialias: true,\n    },\n    isShowingStats: true,\n    useStats: true,\n    useGuiControl: false,\n    useKeyboard: true,\n    isLoaded: false,\n    isMouseMoving: false,\n    isMouseOver: false,\n    maxAnisotropy: 2,\n    bloomPass: {\n        exposure: 1,\n        strength: 0.5,\n        threshold: 0,\n        radius: 0,\n\n    },\n    dpr: 1,\n    layers:{\n        0:{},\n        1:{\n            enabled:true,\n\n            clearColor: 0x000000,\n            exposure: 1,\n            strength: 0.5,\n            bloomStrength: 5,\n            bloomThreshold: 0,\n            bloomRadius: 0,\n        } ,\n        2:{},\n        3:{\n\n            enabled:false,\n            exposure: 1,\n\n            clearColor: 0x000000,\n            strength: 0.5,\n            bloomStrength: 5,\n            bloomThreshold: 0,\n            bloomRadius: 0,\n\t\t\t\tscene: \"Scene with Glow\"\n        } ,\n    },\n    nodes: {\n        material: \"fast\",\n        scale:1,\n        show: true,\n        radius: .5,\n        color: 0x0000ff,\n        edgeColor: 0x0000ff,\n        edgeWidth: 0.1,\n        roughness: 0.5,\n        opacity: 1,\n\n    },\n    edges: {\n        width: 0.5,\n        show: true,\n        color: 0xff,\n        //color: 0x0000ff,\n        roughness: 0.5,\n        opacity: 1,\n\n    },\n\n    fog: {\n        color: 0xffffff,\n        near: 0.0008\n    },\n    camera: {\n        fov: 40,\n        near: 2,\n        far: 1000,\n        aspect: 1,\n    },\n    controls: {\n        autoRotate: false,\n        autoRotateSpeed: -0.5,\n        rotateSpeed: 0.5,\n        zoomSpeed: 0.8,\n        minDistance: 0,\n        maxDistance: 600,\n        minPolarAngle:0,\n        maxPolarAngle: Math.PI ,\n        minAzimuthAngle: -Infinity,\n        maxAzimuthAngle: Infinity,\n        enableDamping: true,\n        dampingFactor: 0.5,\n        enableZoom: true,\n        target: {\n            x: 0,\n            y: 0,\n            z: 0\n        }\n    },\n};\n","\nexport function getMarkerVertexShader(fixedNodeSize=false, fixedColor=false, nodesGroupName='main'){\n    console.info(\"Get Marker Vertex Shader\");\n    let markerVertexShader = `\n\n    #define SHADER_NAME MarkerNode_${nodesGroupName}\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n    uniform mat4 viewMatrix;\n    attribute vec3 position;\n\n    attribute vec3 bufferNodePositions;\n    `\n\n    if (fixedNodeSize){\n        markerVertexShader += 'uniform float bufferNodeSize;'\n    }else{\n        markerVertexShader += 'attribute float bufferNodeSize;'\n    }\n    if (fixedColor){\n        markerVertexShader += 'uniform vec3 bufferColors;'\n    }else{\n\n        markerVertexShader += 'attribute vec3 bufferColors;'\n    }\n\n    markerVertexShader += `\n\n    uniform float bufferOpacity;\n    uniform float bufferNodeScale;\n    uniform float edgeWidth;\n    uniform vec3 edgeColor;\n\n    varying vec3 vColor;\n    varying vec3 vEdgeColor;\n    varying vec3 vPos;\n    varying float vOpacity;\n    varying float vEdgeWidth;\n\n    void main() {\n        vec4 viewNodePos = modelViewMatrix * vec4( bufferNodePositions, 1.0 );\n\n        vec4 mvPosition = viewNodePos +  vec4(position*bufferNodeScale*bufferNodeSize, 0);\n        // if particle size\n        //vec4 mvPosition = viewNodePos +  vec4(position, 0);\n        //gl_PointSize  = bufferNodeScale*bufferNodeSize;\n        //gl_PointSize  = 5.0;\n\n        gl_Position = projectionMatrix * mvPosition;\n\n\n        vColor = bufferColors;\n        vOpacity = bufferOpacity;\n        vPos = position;\n        vEdgeWidth = edgeWidth;\n        vEdgeColor = edgeColor;\n    }\n\n    `\n    return markerVertexShader;\n\n}\n\n","//const sdfFunctions = `\n//vec3 sdfCircle(vec2 p, float s){\n    //float edgeWidth = 1/2.;\n    //float minSdf = 0.5;\n    //float sdf = -length(p) + s;\n    //return vec3(sdf, minSdf, edgeWidth);\n//}\n\n//vec3 sdfSquare(vec2 p, float s){\n //return vec3(sdf, minSdf, edgeWidth);\n//}\n\n//vec3 sdfDiamond(vec2 p, float s){\n //return vec3(sdf, minSdf, edgeWidth);\n//}\n\n//vec3 sdfTriangle(vec2 p, float s){\n //return vec3(sdf, minSdf, edgeWidth);\n//}\n\n//vec3 sdfPentagon(vec2 p, float s){\n //return vec3(sdf, minSdf, edgeWidth);\n//}\n\n//vec3 sdfHexagon(vec2 p, float s){\n //return vec3(sdf, minSdf, edgeWidth);\n//}\n\n//vec3 sdfS6(vec2 p, float s){\n //return vec3(sdf, minSdf, edgeWidth);\n//}\n\n//vec3 sdfProduct(vec2 p, float s){\n //return vec3(sdf, minSdf, edgeWidth);\n//}\n\n//vec3 sdfCross(vec2 p, float s){\n //return vec3(sdf, minSdf, edgeWidth);\n//}\n\n//`\nconst distFunctions = {\n    'o': `\n        edgeWidth = edgeWidth/2.;\n        float minSdf = 0.5;\n        sdf = -length(p) + s;\n    `,\n    's': `\n\n        edgeWidth = edgeWidth/2.;\n        float minSdf = 0.5/2.0;\n        vec2 d = abs(p) - vec2(s, s);\n        sdf = -length(max(d,0.0)) - min(max(d.x,d.y),0.0);\n    `,\n    'd':`\n\n        edgeWidth = edgeWidth/4.;\n        float minSdf = 0.5/2.0;\n        vec2 b  = vec2(s, s/2.0);\n        vec2 q = abs(p);\n        float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n        float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n        sdf = -d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n    `,\n    '^':`\n        float l = s/1.5;\n        float minSdf = 1000.0;\n        float k = sqrt(3.0);\n        p.x = abs(p.x) - l;\n        p.y = p.y + l/k;\n        if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n        p.x -= clamp( p.x, -2.0*l, 0.0 );\n        sdf = length(p)*sign(p.y);\n    `,\n    'p':`\n        edgeWidth = edgeWidth/4.;\n        float minSdf = 0.5/2.0;\n        float r = s/2.0;\n        const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n        p.x = abs(p.x);\n        p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n        p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n        p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);\n        sdf = -length(p)*sign(p.y);\n    `,\n    'h':`\n\n        edgeWidth = edgeWidth/4.;\n        float minSdf = 0.5/2.0;\n        float r = s/2.0;\n        const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n        p = abs(p);\n        p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n        p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n        sdf = -length(p)*sign(p.y);\n    `,\n    's6':`\n\n        float minSdf = 0.5/2.0;\n        edgeWidth = edgeWidth/4.;\n        float r = s/2.0;\n        const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n        p = abs(p);\n        p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n        p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n        p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n        sdf = -length(p)*sign(p.y);\n    `,\n    'x':`\n\n        edgeWidth = edgeWidth/8.;\n        float minSdf = 0.5/4.0;\n\n        float r = s/4.0;\n        float w = 0.5;\n        p = abs(p);\n        sdf = -length(p-min(p.x+p.y,w)*0.5) + r;\n    `,\n    '+':`\n\n        edgeWidth = edgeWidth/4.;\n\n        float minSdf = 0.5/2.0;\n        float r = s/15.0; //corner radius\n        vec2 b = vec2(s/1.0, s/3.0); //base , size\n        //vec2 b = vec2(r, r);\n        p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n        vec2  q = p - b;\n        float k = max(q.y,q.x);\n        vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n        sdf = -sign(k)*length(max(w,0.0)) - r;\n    `\n\n}\nfunction getDistFunction(marker){\n    const exist = Object.keys(distFunctions).includes(marker);\n    if (!exist)\n        marker = 'o'\n\n    return distFunctions[marker]\n}\n\nfunction getShading(marker){\n    let shadingStr = ''\n    if (marker != '3do')\n        return '';\n\n    shadingStr = `\n        // shading\n\n        vec3 normal = normalize(vec3(p.xy, sdf));\n        vec3 direction = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.25, dot(direction, normal));\n        float specular = pow(diffuse, 15.0);\n        color = vec3(max(diffuse*color, specular*vec3(1.0)));\n        //color = vec3(diffuse*color);\n    `\n    return shadingStr;\n\n\n}\n\n\nexport function getMarkerFragmentShader(marker, nodesGroupName='main'){\n    console.info(marker)\n    return  `\n    precision highp float;\n\n    #define SHADER_NAME MarkerNode_${nodesGroupName}\n\n    varying vec3 vColor;\n    varying float vOpacity;\n    varying float vEdgeWidth;\n    varying vec3 vPos;\n    varying vec3 vEdgeColor;\n\n    float ndot(vec2 a, vec2 b ) {\n        return a.x*b.x - a.y*b.y;\n    }\n    void main() {\n\n        vec3 color = vColor;\n        vec3 edgeColor = vEdgeColor;\n        float edgeWidth = vEdgeWidth;\n        vec2 p = vPos.xy;\n        float opacity = vOpacity;\n\n        float s = 0.5;\n        float sdf = 0.0;\n        ${getDistFunction(marker)}\n        if (sdf<0.0) discard;\n\n        //float edge0 = 0.0;\n        //float edge1 = minSdf;\n        float opacity2 = opacity;\n        //if (opacity<1.0) opacity2 =  clamp((sdf - edge0) / (edge1 - edge0), 0.01, opacity) + 0.1;\n        ${getShading(marker)}\n\n        vec4 rgba = vec4(  color, opacity2 );\n\n\n        if (edgeWidth > 0.0){\n            if (sdf < edgeWidth)  rgba  = vec4(edgeColor, 1.0);\n        }\n\n        gl_FragColor = rgba;\n\n    }\n    `\n}\n\nexport const availableMarkers = {\n    'Circle': 'o',\n    'Sphere' :'3do',\n    'Square': 's',\n    'Rhombus' : 'd',\n    'Triangle' : '^' ,\n    'Petagon' : 'p',\n    'Hexagon' : 'h',\n    'Star' : 's6',\n    'Cross' :'+',\n    'X' :'x'\n};\n","/**\n * Return a random string\n * @return {string} A random string with 13 elements\n */\nexport const randomString = ()=>Math.random().toString(36).substring(2, 15);;\n\n/**\n * Random select a element of a given array\n * @param  {array} arr -\n * @return {Object} A random choiced element of the given array\n */\nexport const randomChoice = (arr) => arr[Math.floor(arr.length * Math.random())];\n\n\n","import * as THREE from \"three\";\nimport colormap from \"colormap\"\nimport alertify  from \"alertifyjs\"\n\nimport Config from \"../../../data/config\";\n\nimport { getMarkerImgVertexShader} from \"./shaders/markerImg.vsh.js\";\nimport {markerImgFragmentShader} from \"./shaders/markerImg.fsh.js\";\n\nimport {getMarkerVertexShader} from \"./shaders/marker.vsh.js\";\nimport {getMarkerFragmentShader, availableMarkers} from \"./shaders/marker.fsh.js\";\n\nimport {randomString, randomChoice} from \"../../helpers/tools\";\n\n\n/**\n * Class representing the Nodes of the Graph\n * */\nexport default class Nodes {\n    /**\n     * Create a empty nodes object\n     * @param {object} scene - THREE.scene\n     * @param {bool} use2d - If the nodes should be ploted in 2d\n     */\n    constructor(scene, use2d) {\n        this.scene = scene;\n        this.use2d = use2d;\n\n        this.nodesGroup = {};\n        // This string is used in order to indentify the group of nodes\n        // selected. If the string is empty, then the changes will be applied\n        // across all group of nodes\n        this.selectedGroupName = '';\n\n    }\n    /**\n     * Set the selected group\n     * @param {string} groupName - the name of the group. If the groupName thit not exist\n     *  then set the selecedGroupName as a empty string\n     **/\n    setGroup(groupName){\n        this.selectedGroupName = Object.keys(this.nodesGroup).includes(value)? value : '';\n    }\n    /**\n     * Set the selected group\n     * @param {string} groupName - the name of the group. If the groupName thit not exist\n     *  then set the selecedGroupName as a empty string\n     * @return {array} arr - [[...[string, nodesGroupObj]]\n     **/\n    getGroup(){\n        const allGroups = Object.entries(this.nodesGroup);\n        const arr = this.selectedGroupName != ''? [[this.selectedGroupName, this.nodesGroup[this.selectedGroupName]]] : allGroups;\n        return arr;\n    }\n    /**\n     * Set the selected group\n     * @param {string} groupName - the name of the group. If the groupName thit not exist\n     *  then set the selecedGroupName as a empty string\n     **/\n    colorByField(prop){\n        for (const [nodesGroupName, nodesObj] of this.getGroup() ) {\n\n            let bufferColors = nodesObj.nodesData[prop].flat()\n            if (bufferColors.length != nodesObj.numNodes*3){\n                alertify.error(` ${prop} it's not in RGB format `)\n                return\n            }else{\n                this.updateColors(bufferColors, nodesGroupName);\n            }\n\n        }\n    }\n\n    updateColors(colors, nodesGroupName){\n\n        let nodesObj = this.nodesGroup[nodesGroupName];\n        if (nodesObj.fixedColor){\n            let fixedColor = false;\n            nodesObj.mesh.material.vertexShader = getMarkerVertexShader(nodesObj.fixedNodeSize, fixedColor, nodesGroupName);\n\n            nodesObj.mesh.geometry.addAttribute(\"bufferColors\",\n                new THREE.InstancedBufferAttribute(new Float32Array(colors), 3, false));\n\n            nodesObj.fixedColor = fixedColor;\n            delete nodesObj.uniforms.bufferColors;\n            nodesObj.mesh.geometry.needsUpdate = true;\n\n        }else{\n            nodesObj.mesh.geometry.attributes.bufferColors.array = new Float32Array(colors);\n            nodesObj.mesh.geometry.attributes.bufferColors.needsUpdate = true\n\n\n        }\n        nodesObj.mesh.material.needsUpdate = true;\n\n\n    }\n    colorByProp(prop){\n\n        for (const [nodesGroupName, nodesObj] of this.getGroup() ) {\n\n            let colors = colormap({\n                colormap: \"jet\",\n                nshades: nodesObj.numNodes,\n                format: \"float\",\n                alpha: 1\n            })\n            let values = nodesObj.nodesData[prop]\n\n            const bufferColors = colors\n                .map((color, index) => [values[String(index)], color]) // add the prop to sort by\n                .sort(([val1], [val2]) => val2 - val1) // sort by the prop data\n                .map(([, color]) => color)\n                .map(([r, g, b, alpha])=>[r, g, b])\n                .flat()\n            this.updateColors(bufferColors, nodesGroupName);\n\n        }\n    }\n    updateColor(color, nodesGroupName){\n\n        let nodesObj = this.nodesGroup[nodesGroupName];\n        if (nodesObj.fixedColor){\n            nodesObj.uniforms.bufferColors.value = color;\n            //nodesObj.mesh.geometry.needsUpdate = true;\n        }else{\n            let fixedColor = true;\n            nodesObj.uniforms.bufferColors = {\n                type: 'vec3',\n                value: color\n            }\n            nodesObj.mesh.geometry.deleteAttribute('bufferColors');\n            nodesObj.mesh.material.vertexShader = getMarkerVertexShader(nodesObj.fixedNodeSize, fixedColor, nodesGroupName);\n\n            nodesObj.fixedColor = true;\n            nodesObj.mesh.geometry.needsUpdate = true;\n            nodesObj.fixedColor = true;\n        }\n        nodesObj.mesh.material.needsUpdate = true;\n\n    }\n    updateMarker(marker, nodesGroupName){\n\n        let nodesObj = this.nodesGroup[nodesGroupName];\n        nodesObj.mesh.material.vertexShader = getMarkerVertexShader(\n            nodesObj.fixedNodeSize, nodesObj.fixedColor, nodesGroupName);\n\n        nodesObj.mesh.material.fragmentShader = getMarkerFragmentShader(\n            marker, nodesGroupName);\n\n        nodesObj.mesh.material.needsUpdate = true;\n\n\n    }\n    changeMarker(marker){\n\n        for (const [nodesGroupName, nodesObj] of this.getGroup() ) {\n            this.updateMarker(marker, nodesGroupName);\n\n        }\n    }\n    stopUpdate(){\n\n        for (const [nodesGroupName, nodesObj] of this.getGroup() ) {\n            nodesObj.mesh.geometry.needsUpdate = false\n            nodesObj.mesh.material.needsUpdate =false;\n        }\n    }\n\n\n\n    changeColor(colorHEX){\n\n        for (const [nodesGroupName, nodesObj] of this.getGroup() ) {\n            let color = new THREE.Color(colorHEX);\n            this.updateColor(color, nodesGroupName);\n\n        }\n    }\n    //size gui interaction\n    sizeByField(prop){\n\n        for (const [nodesGroupName, nodesObj] of this.getGroup() ) {\n\n            let bufferNodeSize = nodesObj.nodesData[prop].flat()\n            if (bufferNodeSize.length != nodesObj.numNodes){\n                alertify.error(` ${prop} it's not in a valid format `)\n                return\n            }else{\n                this.updateSizes(bufferNodeSize, nodesGroupName);\n            }\n\n        }\n    }\n\n    updateSizes(sizes, nodesGroupName){\n\n        let nodesObj = this.nodesGroup[nodesGroupName];\n        let sMin = Math.min(...sizes)\n        let sMax = Math.max(...sizes)\n        sizes = sizes.map((s)=> (s-sMin)/(sMax-sMin))\n        if (nodesObj.fixedNodeSize){\n            let fixedNodeSize = false;\n            nodesObj.mesh.material.vertexShader = getMarkerVertexShader(fixedNodeSize, nodesObj.fixedColor, nodesGroupName);\n\n\n            let sizesBuffer = new THREE.InstancedBufferAttribute(new Float32Array(sizes), 1, true);\n            nodesObj.mesh.geometry.addAttribute(\"bufferNodeSize\",\n                sizesBuffer);\n\n            nodesObj.fixedNodeSize = fixedNodeSize;\n            delete nodesObj.uniforms.bufferNodeSizes;\n            nodesObj.mesh.geometry.needsUpdate = true;\n\n        }else{\n            nodesObj.mesh.geometry.attributes.bufferNodeSizes.array = new Float32Array(sizes);\n            nodesObj.mesh.geometry.attributes.bufferNodeSizes.needsUpdate = true\n\n        }\n        nodesObj.mesh.material.needsUpdate = true;\n\n\n    }\n    updateSize(size, nodesGroupName){\n\n        let nodesObj = this.nodesGroup[nodesGroupName];\n        if (nodesObj.fixedNodeSize){\n            nodesObj.uniforms.bufferNodeSizes.value = color;\n            //nodesObj.mesh.geometry.needsUpdate = true;\n        }else{\n            let fixedNodeSize = true;\n            nodesObj.uniforms.bufferNodeSizes = {\n                type: 'vec3',\n                value: color\n            }\n            nodesObj.mesh.geometry.deleteAttribute('bufferNodeSizes');\n            nodesObj.mesh.material.vertexShader = getMarkerVertexShader(nodesObj.fixedNodeSize, fixedNodeSize, nodesGroupName);\n            nodesObj.fixedNodeSize = true;\n            nodesObj.mesh.geometry.needsUpdate = true;\n            nodesObj.fixedNodeSize = true;\n        }\n        nodesObj.mesh.material.needsUpdate = true;\n\n    }\n\n\n    // end size gui itneraction\n    changeRadius(value){\n        this.instancedNodes.geometry.attributes.bufferRadius = value;\n        this.instancedNodes.material.needsUpdate = true;\n    }\n\n    changeEdgeColor(color){\n        for (const [nodesGroupName, nodesObj] of this.getGroup() ) {\n            //for (let nodesObj of this.nodesGroup){\n            nodesObj.uniforms.edgeColor.value = new THREE.Color(color);\n            nodesObj.mesh.geometry.needsUpdate = true;\n        }\n    }\n    changeEdgeWidth(value){\n\n        for (const [nodesGroupName, nodesObj] of this.getGroup() ) {\n            //for (let nodesObj of this.nodesGroup){\n            nodesObj.uniforms.edgeWidth.value = value;\n            nodesObj.mesh.geometry.needsUpdate = true;\n        }\n    }\n\n    changeOpacity(value){\n\n        for (const [nodesGroupName, nodesObj] of this.getGroup() ) {\n            //for (let nodesObj of this.nodesGroup){\n            nodesObj.uniforms.bufferOpacity.value = value;\n            nodesObj.mesh.geometry.needsUpdate = true;\n        }\n    }\n    changeScale(value){\n\n        for (const [nodesGroupName, nodesObj] of this.getGroup() ) {\n            //for (let nodesObj of this.nodesGroup){\n            nodesObj.uniforms.bufferNodeScale.value = value;\n            nodesObj.mesh.geometry.needsUpdate = true;\n            nodesObj.mesh.material.needsUpdate = true;\n        }\n    }\n\n    updateNodePositions(positions){\n        this.instancedNodes.geometry.attributes.bufferNodePositions.array = new Float32Array(positions);\n        this.instancedNodes.geometry.attributes.bufferNodePositions.needsUpdate = true\n    }\n\n\n\n    deleteAllNodes(){\n        for (const [key, nodesObj] of Object.entries(this.nodesGroup)) {\n            nodesObj.mesh.geometry.dispose();\n            nodesObj.mesh.material.dispose();\n            nodesObj.mesh.geometry.needsUpdate = true;\n            nodesObj.mesh.material.needsUpdate = true;\n            this.scene.remove(nodesObj.mesh);\n            delete this.nodesGroup[key];\n        }\n    }\n    createNodes(nodesData,  clear=false) {\n        let nodesGroupName;\n        if (clear){\n            nodesGroupName = 'main';\n        }else{\n            nodesGroupName = nodesData.props.includes('name')? nodesData.name : randomString();\n        }\n        console.info(\"Creating nodes\", nodesGroupName);\n\n\n        let nodesObj = {}\n\n        const numNodes = Object.keys(nodesData.id).length\n        const fixedNodeSize = nodesData.props.includes(\"size\") == false;\n        const fixedColor = nodesData.props.includes(\"color\") == false;\n\n        if (clear) this.deleteAllNodes();\n\n        let bufferNodePositions = nodesData.pos;\n\n        let uniforms = {\n            bufferOpacity: {\n                type: 'f', // a float\n                value: 1\n            },\n            bufferNodeScale:{\n                type: 'f',\n                value: 1\n            },\n        };\n        let bufferNodeSize;\n        if (fixedNodeSize){\n            console.info(\"Fixed Node Size\")\n            uniforms.bufferNodeSize = {\n                type: 'f',\n                value: 1\n            }\n        }\n        if (fixedColor){\n            console.info(\"Fixed Color\")\n            uniforms.bufferColors = {\n                type: 'vec3',\n                value: new Float32Array([0.8, 0.0, 0.8])\n            }\n\n        }\n\n        let nodesMesh;\n\n        let material;\n        let instancedGeometry = new THREE.InstancedBufferGeometry();\n        //if (marker=='1'){\n        ////\n        //let markerGeometry = new  THREE.PlaneBufferGeometry(1, 1, 1)\n        ////let circleGeometry = new  THREE.CircleBufferGeometry(1, 6)\n        //instancedGeometry.index = markerGeometry.index;\n        //instancedGeometry.attributes = markerGeometry.attributes;\n        //this.uniforms.map = { value: new THREE.TextureLoader().load( `textures/sprites/${markerImg}.png` ) }\n        //this.uniforms.useDiffuse2Shadow = {\n        //type: 'f',\n        //value: 0,\n        //}\n        //this.uniforms.edgeColor = {\n        //type: 'vec3',\n        //value: new Float32Array([0.8, 0.8, 0.8])\n        //}\n\n\n        ////instancedGeometry = instancedGeometry.copy(circleGeometry);\n        //material = new THREE.RawShaderMaterial( {\n        ////vertexShader: markerVertexShader,\n        //vertexShader: getMarkerImgVertexShader(fixedNodeSize, fixedColor),\n        //fragmentShader: markerImgFragmentShader,\n        //uniforms: this.uniforms,\n        //transparent: true,\n        ////blending: THREE.AdditiveBlending,\n        //blending: THREE.NormalBlending,\n        ////depthTest: true,\n        ////depthTest: false,\n        //depthWrite: true,\n        //} );\n\n        //}else{\n        //let symbol = \"^\";\n\n        let marker = nodesData.props.includes(\"marker\") == false ? randomChoice(Object.values(availableMarkers)): nodesData.marker;\n        marker = '3do'\n\n        let markerGeometry = new  THREE.PlaneBufferGeometry(1, 1, 1)\n\n        instancedGeometry = instancedGeometry.copy(markerGeometry);\n        instancedGeometry.maxInstancedCount = numNodes;\n\n        uniforms.edgeColor = {\n            type: 'vec3',\n            value: new THREE.Color(Config.nodes.edgeColor),\n        }\n        uniforms.edgeWidth = {\n            type: 'f',\n            value: 0.0,\n        }\n        material = new THREE.RawShaderMaterial( {\n            vertexShader: getMarkerVertexShader(fixedNodeSize, fixedColor, nodesGroupName),\n            fragmentShader: getMarkerFragmentShader(marker, nodesGroupName),\n            uniforms: uniforms,\n            transparent: true,\n            //blending: THREE.AdditiveBlending,\n            //blending: THREE.NormalBlending,\n            depthTest: !this.use2d,\n            //depthTest: false,\n            depthWrite: true,\n        } );\n\n        if(fixedNodeSize == false)\n            instancedGeometry.addAttribute(\n                \"bufferNodeSize\",\n                new THREE.InstancedBufferAttribute(new Float32Array(nodesData.size), 1, true)\n            );\n        if(fixedColor == false)\n            instancedGeometry.addAttribute(\"bufferColors\",\n                new THREE.InstancedBufferAttribute(new Float32Array(nodesData.color.flat()), 3, false));\n\n        instancedGeometry.addAttribute(\"bufferNodePositions\",\n            new THREE.InstancedBufferAttribute(new Float32Array(bufferNodePositions), 3, false)\n        );\n\n        nodesMesh = new THREE.Mesh(instancedGeometry, material);\n\n        this.scene.add(nodesMesh);\n\n        nodesObj.mesh = nodesMesh;\n        nodesObj.nodesData = nodesData;\n        nodesObj.uniforms = uniforms;\n        nodesObj.marker = marker;\n        nodesObj.fixedNodeSize = fixedNodeSize;\n        nodesObj.fixedColor = fixedColor;\n        nodesObj.numNodes = numNodes;\n\n        this.nodesGroup[nodesGroupName] = nodesObj;\n\n    }\n\n\n}\n","import * as THREE from \"three\";\nimport colormap from \"colormap\"\nimport alertify  from \"alertifyjs\"\nimport {MeshLine} from \"three\";\n\nexport default class Edges {\n    constructor(scene, layer, bloomLayer) {\n        this.createEdges = this.createEdges.bind(this);\n\n        this.scene = scene;\n        this.layer = layer\n        this.bloomLayer = bloomLayer\n\n        this.numEdges = 0\n        this.edgesData = {}\n        this.instancedEdges\n\n\n    }\n\n    //deleteByNode(nodeId){\n    //}\n    updateNodePositions(positions){\n        let positionVertices = []\n        //A simple arrow function  in order to clean the code\n        const f = (arr, index) => arr.push(...[0, 1, 2].map((i)=>positions[index+i]))\n        for (let [s, t] of this.edgesData.nodes) {\n            let id_s = s*3\n            let id_t = t*3\n            //positionVertices.push(\n                //positions[id_s],\n            //)\n            f(positionVertices, id_s)\n            f(positionVertices, id_t)\n        }\n        this.instancedEdges.geometry.attributes.position.array = new Float32Array(positionVertices);\n        this.instancedEdges.geometry.attributes.position.needsUpdate = true\n        this.instancedEdges.geometry.computeBoundingSphere();\n    }\n    changeColorUniform(colorHex){\n\n        let color = new THREE.Color(colorHex);\n        this.instancedEdges.material.color = color;\n        this.instancedEdges.material.needsUpdate = true;\n  \n    }\n     changeWidth(width){\n\n        this.instancedEdges.material.linewidth = width;\n        this.instancedEdges.material.needsUpdate = true;\n  \n    }\n    colorByProp(prop){\n        let colors = colormap({\n            colormap: \"jet\",\n            nshades: this.numEdges,\n            format: \"float\",\n            alpha: 1\n        })\n        let values = this.edgesData[prop]\n\n        const bufferColors = colors\n            .map((color, index) => [values[index], color]) // add the prop to sort by\n            .sort(([val1], [val2]) => val2 - val1) // sort by the prop data\n            .map(([, color]) => color)\n            .map(([r, g, b, alpha])=>[r, g, b, r, g, b])\n            .flat()\n\n        if (bufferColors.length != this.numEdges*6){\n            alertify.error(\"Invalid prop\")\n            alert(\"prop fail\")\n            return\n        }\n\n        this.instancedEdges.geometry.attributes.color.array = new Float32Array(bufferColors);\n        this.instancedEdges.geometry.attributes.color.needsUpdate = true\n        this.instancedEdges.material.needsUpdate = true;\n\n    }\n    changeOpacity(value){\n        this.instancedEdges.material.opacity=value;\n        //this.instancedEdges.material.blending=THREE.AdditiveBlending,c\n        this.instancedEdges.material.needsUpdate = true;\n    }\n    ressetVerticesPos(nodesData, edgesData) {\n        this.createVertices(nodesData, edgesData)\n        this.updateGeometry()\n    }\n    updateGeometry(){\n        this.edges.geometry.dispose();\n        this.edges.geometry = new THREE.BufferGeometry().setFromPoints(\n            Object.values(this.vertices)\n        );\n    }\n    //deleteEdge(edgeName){\n        //if (!(edgeName in this.segments)) return\n        //let inName = this.segments[edgeName][1]\n        //let outName = this.segments[edgeName][0]\n        //delete this.segments[edgeName]\n        //delete this.vertices[inName]\n        //delete this.vertices[outName]\n        //this.updateGeometry()\n    //}\n    createVertices(nodesData, edgesData, defaultProps){\n        this.vertices = {}\n        this.segments = {}\n        var positions = [];\n        var colors = [];\n        let r = 800\n        let color;\n\n        const f = (arr, index) => arr.push(...[0, 1, 2].map((i)=>{\n            let pos = nodesData.pos[index*3+i]\n            if(i==2)\n                pos = pos-0.01\n            return pos\n        }))\n        for (let [s, t] of edgesData.nodes) {\n\n            //let geometry = new THREE.Geometry();\n            //  let i = 0;\n            //if (i<1) return\n            //\n            const nodeInId = nodesData.id[s]\n            const nodeOutId = nodesData.id[t]\n            if ((Math.random())>-1){\n            //let edgeName = `${nodeInId}-to-${nodeOutId}`\n            //\n            f(positions, t)\n            f(positions, s)\n            //let [x, y, z] = nodesData.pos[t]\n            //positions.push( x, y, z );\n            //[x, y, z] = nodesData.pos[s]\n            //positions.push( x, y, z );\n            //colors.push(...nodesData.color[t])\n            //colors.push(...nodesData.color[s])\n            //colors.push(...[1, 1, 1, 1, 1,1])\n            //colors.push(0.8);\n            //colors.push(0.8);\n            //colors.push(0.8);\n            //colors.push(0.8);\n            //colors.push(0.8);\n            //colors.push(0.8);\n\n\n\n        }\n\n        }\n        this.positions = positions;\n        this.colors = colors;\n    }\n    deleteAllEdges(){\n        if(this.instancedEdges){\n            this.instancedEdges.geometry.dispose()\n            this.instancedEdges.material.dispose()\n            this.instancedEdges.geometry.needsUpdate = true;\n            this.instancedEdges.material.needsUpdate = true;\n            this.scene.remove(this.instancedEdges)\n            this.instancedEdges = null;\n        }\n    }\n\n    createEdges(nodesData, edgesData) {\n        this.deleteAllEdges()\n\n        this.edgesData = edgesData\n        this.numEdges = this.edgesData.nodes.length\n        this.createVertices(nodesData, edgesData)\n        var geometry = new THREE.BufferGeometry();\n        var material = new THREE.LineBasicMaterial( {\n            vertexColors: false,\n            blending: THREE.AdditiveBlending,\n            transparent:true,\n            color: 0xfff,\n            opacity:0.4, linewidth:2 } );\n\n        geometry.setAttribute( \"position\", new THREE.Float32BufferAttribute( this.positions, 3 ) );\n        //geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( this.colors, 3 ) );\n\n        geometry.computeBoundingSphere();\n\n        let edges = new THREE.Line( geometry, material );\n        this.instancedEdges = edges\n        this.scene.add( edges );\n    }\n}\n","const ALIAS = {\n  'left'\t\t: 37,\n  'up'\t\t  : 38,\n  'right'\t\t: 39,\n  'down'\t\t: 40,\n  'space'\t\t: 32,\n  'tab'\t\t  : 9,\n  'escape'\t: 27\n};\n\nexport default class Keyboard {\n  constructor(domElement) {\n    this.domElement = domElement || document;\n    this.keyCodes = {};\n\n    // bind keyEvents\n    this.domElement.addEventListener('keydown', (event) => this.onKeyChange(event), false);\n    this.domElement.addEventListener('keyup', (event) => this.onKeyChange(event), false);\n\n    // bind window blur\n    window.addEventListener('blur', () => this.onBlur, false);\n  }\n\n  destroy() {\n    this.domElement.removeEventListener('keydown', (event) => this.onKeyChange(event), false);\n    this.domElement.removeEventListener('keyup', (event) => this.onKeyChange(event), false);\n\n    // unbind window blur event\n    window.removeEventListener('blur', () => this.onBlur, false);\n  }\n\n  onBlur() {\n    for(const prop in this.keyCodes)\n      this.keyCodes[prop] = false;\n  }\n\n  onKeyChange(event) {\n    // log to debug\n    //console.log('onKeyChange', event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey)\n\n    // update this.keyCodes\n    const keyCode = event.keyCode;\n    this.keyCodes[keyCode] = event.type === 'keydown';\n  }\n\n  pressed(keyDesc) {\n    const keys = keyDesc.split('+');\n    for(let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      let pressed = false;\n      if(Object.keys(ALIAS).indexOf(key) != -1) {\n        pressed = this.keyCodes[ALIAS[key]];\n      } else {\n        pressed = this.keyCodes[key.toUpperCase().charCodeAt(0)];\n      }\n      if(!pressed)\n        return false;\n    }\n\n    return true;\n  }\n\n  eventMatches(event, keyDesc) {\n    const aliases = ALIAS;\n    const aliasKeys = Object.keys(aliases);\n    const keys = keyDesc.split('+');\n    // log to debug\n    // console.log('eventMatches', event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey)\n    for(let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      let pressed = false;\n      if(key === 'shift') {\n        pressed = event.shiftKey ? true : false;\n      } else if(key === 'ctrl') {\n        pressed = event.ctrlKey ? true : false;\n      } else if(key === 'alt') {\n        pressed = event.altKey ? true : false;\n      } else if(key === 'meta') {\n        pressed = event.metaKey ? true : false;\n      } else if(aliasKeys.indexOf(key) !== -1) {\n        pressed = event.keyCode === aliases[key];\n      } else if(event.keyCode === key.toUpperCase().charCodeAt(0)) {\n        pressed = true;\n      }\n      if(!pressed)\n        return false;\n    }\n\n    return true;\n  }\n}\n","import Keyboard from \"../../utils/keyboard\";\nimport Helpers from \"../../utils/helpers\";\n//import Config from \"../../data/config\";\nimport alertify  from \"alertifyjs\"\n// Manages all input interactions\nexport default class Interaction {\n    constructor(canvas, appState, Config, datGui, keypressFunc) {\n        // Properties\n        this.canvas = canvas;\n        this.keypressFunc = keypressFunc\n        this.datGui = datGui\n        this.timeout = null;\n\n        // Instantiate keyboard helper\n        this.keyboard = new Keyboard();\n\n        //this.keyboard = new Keyboard(document.getElementById('containergraphCanvas'));\n\n        // Listeners\n        // Mouse events\n\n\n        this.keypressEvent = this.keypressEvent.bind(this)\n        // Keyboard events\n        this.keyboard.domElement.addEventListener(\"keydown\", (event) => this.keypressEvent(event)\n            // Only once\n\n            //if(this.keyboard.eventMatches(event, 'escape')) {\n            //  console.log('Escape pressed');\n            // }\n        );\n        this.appState = appState\n    }\n    keypressEvent(event){\n        let repeat = event.repeat\n        let key = event.key\n        let alertHTMLobj = document.getElementById(\"bootstraAlertStrong\")\n        //let bootstrapAlert = document.getElementById(\"bootstrapAlert\")\n        let bootstrapAlert = $(\"#bootstrapAlert\")\n        switch (key.toLowerCase()) {\n            case \"e\":\n                alertify.message(\"Edition Mode\")\n                this.datGui.closed = true\n                this.appState.vimMode = \"Edition\";\n                console.info(\"Vim mode Edition\");\n                break;\n\n            case \"v\":\n                alertify.message(\"Visual Mode\")\n                this.datGui.closed = false\n                this.appState.vimMode = \"Visual\";\n                console.info(\"Vim mode Visualization\");\n                break;\n            case \"n\":\n                alertify.message(\"Navigation Mode\")\n                this.datGui.closed = true\n                this.appState.vimMode = \"Navigation\";\n                break;\n\n            case \"s\":\n                document.getElementById(\"widthSaveImage\").value = window.innerWidth\n                document.getElementById(\"heightSaveImage\").value = window.innerHeight\n\n                this.keypressFunc (key,\"saveImg\")\n\n            case \"d\":\n                if (this.appState.vimMode == \"Edition\")\n                    this.keypressFunc(key, \"deleteNode\")\n                break;\n\n\n            case \"l\":\n            case \"j\":\n            case \"i\":\n            case \"k\":\n\n                if ((this.appState.vimMode == \"Visual\") &&(key==\"l\")){\n                    alertify.confirm(\"Are you sure you want to reload the graph?\",\n                        ()=>{\n                            this.keypressFunc(key, \"reloadGraph\")\n                        });\n                }\n\n                if (this.appState.vimMode == \"Edition\"){\n                    this.keypressFunc(key, \"move\")\n                    repeat = false\n                }\n                break;\n\n            case \"r\":\n                if (this.appState.vimMode == \"Visual\")\n                    alertify.message(\"Recalculating  positions\")\n                    this.keypressFunc (key,\"recalcPos\")\n                break;\n\n\n\n            default:\n                break;\n        }\n        if (repeat) {\n            return;\n        }\n\n        //console.log(\"keydown\", event);\n    }\n}\n","import * as THREE from \"three\";\nimport * as dat from 'dat.gui';\n\nimport {availableMarkers} from \"./../components/nodes/shaders/marker.fsh.js\";\n\n/**\n * Update the dropdown itens related with a given datGUI element\n * @param  {DOMGui} datGUI select element\n * @param  {Array} Array of strings with the dropdown itens\n */\nfunction updateDropdown(target, list){\n    let innerHTMLStr = \"\";\n    for(var i=0; i<list.length; i++){\n        var str = \"<option value='\" + list[i] + \"'>\" + list[i] + \"</option>\";\n        innerHTMLStr += str;\n    }\n\n    if (innerHTMLStr != \"\") target.domElement.children[0].innerHTML = innerHTMLStr;\n}\n\n// Manages all dat.GUI interactions\nexport default class DatGUI {\n    constructor(\n        idCanvasHTML,\n        scene, renderer,\n        camera,\n        nodes0, edges0,\n        Config,\n        appState) {\n        const gui = new dat.GUI({autoPlace:false, name:idCanvasHTML});\n        this.gui = gui\n\n        //container.appendChild(gui.domElement);\n        document.getElementById(`datGui${idCanvasHTML}`).appendChild(gui.domElement);\n        const render = renderer.render;\n        //canvas.appendChild(gui.domElement);\n        //this.camera = main.camera.threeCamera;\n        //this.controls = main.controls.threeControls;\n        //this.light = main.light;\n\n        /* Scene */\n        let sceneFolder = gui.addFolder('Scene');\n\n        sceneFolder.addColor(Config.scene, \"color\").name('Color').onChange((color) => {\n            scene.background = new THREE.Color(color)\n            render()\n        });\n\n        \n        /* Nodes */\n        let nodesFolder = gui.addFolder('Nodes');\n        this.comunityField = nodesFolder.add(appState, \"comunityField\", appState.comunityField)\n            .name(\"Comunity\")\n            .onChange(function(value) {\n                nodes0.setComunity(value)\n            });\n        let markers = {\n            marker : {\n                \"--\" : \"\"\n            }\n        }\n        nodesFolder.add(markers, \"marker\", availableMarkers)\n            .name(\"marker\")\n            .onChange(function(value) {\n                nodes0.changeMarker(value)\n                render();\n            });\n        nodesFolder.add( Config.nodes, 'show' ).onChange( function ( value ) {\n            for (let [nodeName, node] of Object.entries(nodes0.nodes)){\n                node.visible=value;\n            }\n\n            Config.nodes.show = value\n            render();\n        } );\n\n        nodesFolder.addColor(Config.nodes, \"color\").name('Color').onChange((color) => {\n            nodes0.changeColor(color)\n            render()\n        });\n        this.sizeField = nodesFolder.add(appState, \"defaultProps\", appState.defaultProps)\n            .name(\"Size Field\")\n            .onChange(function(value) {\n                nodes0.sizeByField(value)\n\n                render();\n            });\n        nodesFolder.add(Config.nodes, 'scale', 0.01, 10, 0.01).name('Scale').onChange((value) => {\n            nodes0.changeScale(value)\n\n            render();\n            //node.material.opacity=value;\n        });\n        nodesFolder.addColor(Config.nodes, \"edgeColor\").name('Edge Color').onChange((color) => {\n            nodes0.changeEdgeColor(color)\n            render()\n        });\n        nodesFolder.add(Config.nodes, 'edgeWidth', 0.0, 1, 0.01).name('Edge Width').onChange((value) => {\n            nodes0.changeEdgeWidth(value)\n            render()\n            //node.material.opacity=value;\n        });\n        nodesFolder.add(Config.nodes, 'opacity', 0, 1).name('Opacity').onChange((value) => {\n            nodes0.changeOpacity(value)\n\n            render();\n            //node.material.opacity=value;\n        });\n\n        this.colorProp = nodesFolder.add(appState, \"defaultProps\", appState.defaultProps)\n            .name(\"Color by Attr.\")\n            .onChange(function(value) {\n                nodes0.colorByProp(value)\n            });\n        this.colorField = nodesFolder.add(appState, \"defaultProps\", appState.defaultProps)\n            .name(\"Color Field\")\n            .onChange(function(value) {\n                nodes0.colorByField(value)\n            });\n\n\n\n        this.nodesFolder = nodesFolder\n\n        /* Edges */\n        let edgesFolder = gui.addFolder('Edges');\n\n        edgesFolder.add( Config.edges, 'show' ).onChange( function ( value ) {\n\n            Config.edges.show = value\n            render();\n        } );\n        //edgesFolder.addColor(Config.edges, \"color\").name('Color')\n        //.onChange((color) => {\n        //edges0.changeColor(color)\n        //});\n        edgesFolder.add(Config.edges, 'opacity', 0, 1).name('Opacity').onChange((value) => {\n            edges0.changeOpacity(value)\n\n            render();\n            //node.material.opacity=value;\n        });\n\n     edgesFolder.add(Config.edges, 'width', 0.0, 5, 0.01).name('Width').onChange((value) => {\n            edges0.changeWidth(value)\n            render()\n            //node.material.opacity=value;\n        });\n        let colorEdge = {prop:[], field:[]}\n     \n        this.colorEdgeField = edgesFolder.add(colorEdge, \"field\", colorEdge.prop)\n            .name(\"Color by Field.\")\n            .onChange(function(value) {\n                edges0.colorByField(value)\n            });\n\n        //nodesFolder.add(Config.nodes, 'scale', 0.01, 5).name('Scale').onChange((value) => {\n        //nodes0.changeScale(value)\n        ////node.material.opacity=value;\n        //});\n        edgesFolder.addColor(Config.edges, \"color\").name('Color').onChange((color) => {\n            edges0.changeColorUniform(color)\n            render()\n        });\n        edgesFolder.add(Config.edges, 'opacity', 0, 1).name('Opacity').onChange((value) => {\n            edges0.changeOpacity(value)\n            //node.material.opacity=value;\n        });\n\n        //Edges Bloom\n\n        //edgesFolder.addColor(Config.layers[edgesBloomScene], 'clearColor' ).onChange( function ( color ) {\n\n        //bloomPassEdges.clearColor.set(color)\n        //render()\n        //});\n\n        //edgesFolder.add( Config.layers[edgesBloomScene], 'enabled' ).onChange( function ( value ) {\n\n        //bloomPassEdges.enabled = value\n        //render();\n        //} );\n        //edgesFolder.add( Config.layers[edgesBloomScene], 'strength', 0.0, 2 ).onChange( function ( value ) {\n        ////bloomPassEdges.copyUniforms.opacity(value)\n        //bloomPassEdges.strength = value\n        //render();\n        //} );\n\n\n        //edgesFolder.add( Config.layers[edgesBloomScene], 'exposure', 0.01, 2 ).onChange( function ( value ) {\n        //renderer.toneMappingExposure = Math.pow( value, 1.0 );\n        //render();\n        //} );\n\n        //edgesFolder.add( Config.layers[edgesBloomScene], 'bloomThreshold', 0.0, 10 ).step(0.01).onChange( function ( value ) {\n        //bloomPassEdges.threshold = Number( value )/100;\n        //render();\n        //} );\n\n        //edgesFolder.add( Config.layers[edgesBloomScene], 'bloomStrength', 0.0, 2.0 ).onChange( function ( value ) {\n        //bloomPassEdges.strength = Number( value );\n        //render();\n        //} );\n\n        //edgesFolder.add( Config.layers[edgesBloomScene], 'bloomRadius', 0.0, 1.0 ).step( 0.01 ).onChange( function ( value ) {\n        //bloomPassEdges.radius = Number( value );\n        //render();\n        //} );\n        let renderFolder = gui.addFolder('Render');\n        renderFolder.add( Config.bloomPass, 'exposure', 0.1, 5 ).onChange( function ( value ) {\n\n            renderer.toneMappingExposure = Math.pow( value, 4.0 );\n            render()\n\n        } );\n        renderFolder.add( Config.bloomPass, 'threshold', 0.0, 1.0 ).onChange( function ( value ) {\n\n            renderer.bloomPass.threshold = Number( value );\n            render()\n\n        } );\n\n        renderFolder.add( Config.bloomPass, 'strength', 0.0, 10.0 ).onChange( function ( value ) {\n\n            renderer.bloomPass.strength = Number( value );\n            render()\n\n        } );\n\n        renderFolder.add( Config.bloomPass, 'radius', 0.0, 1.0 ).step( 0.01 ).onChange( function ( value ) {\n\n            renderer.bloomPass.radius = Number( value );\n            render()\n\n        } );\n        //nodesFolder.open()\n        //sceneFolder.open()\n        //edgesFolder.open()\n        //renderFolder.open()\n\n        /* Controls */\n        //const controlsFolder = gui.addFolder('Controls');\n        //controlsFolder.add(Config.controls, 'autoRotate').name('Auto Rotate').onChange((value) => {\n        //this.controls.autoRotate = value;\n        //});\n        //const controlsAutoRotateSpeedGui = controlsFolder.add(Config.controls, 'autoRotateSpeed', -1, 1).name('Rotation Speed');\n        //controlsAutoRotateSpeedGui.onChange((value) => {\n        //this.controls.enableRotate = false;\n        //this.controls.autoRotateSpeed = value;\n        //});\n        //controlsAutoRotateSpeedGui.onFinishChange(() => {\n        //this.controls.enableRotate = true;\n        //});\n\n        renderer.updateSize();\n        /* Mesh */\n\n    }\n    updateComunityField(values){\n        values.unshift('');\n        updateDropdown(this.comunityField , values);\n    }\n    updateNodeColorProp(values){\n        values.unshift('');\n        values = values.filter(v=> v != 'pos')\n        updateDropdown(this.colorField , values);\n        updateDropdown(this.colorProp , values);\n        updateDropdown(this.sizeField , values.filter(v=> v!='color'));\n    }\n    updateEdgeColorProp(values){\n        values.unshift('');\n        updateDropdown(this.colorEdgeField , values);\n        updateDropdown(this.colorEdgeProp , values);\n    }\n\n\n\n}\n\n//unreal bloom effect\n//enabled: true\n//needsSwap: false\n//clear: false\n//renderToScreen: true\n//strength: 5\n//radius: 0\n//threshold: 0\n//resolution: Vector2 {x: 1366, y: 348}\n//clearColor: Color\n//r: 255\n//g: 255\n//b: 255\n//__proto__: Object\n//renderTargetsHorizontal: (5) [WebGLRenderTarget, WebGLRenderTarget, WebGLRenderTarget, WebGLRenderTarget, WebGLRenderTarget]\n//renderTargetsVertical: (5) [WebGLRenderTarget, WebGLRenderTarget, WebGLRenderTarget, WebGLRenderTarget, WebGLRenderTarget]\n//nMips: 5\n//renderTargetBright: WebGLRenderTarget {width: 683, height: 174, scissor: Vector4, scissorTest: false, viewport: Vector4, …}\n//highPassUniforms: {tDiffuse: {…}, luminosityThreshold: {…}, smoothWidth: {…}, defaultColor: {…}, defaultOpacity: {…}}\n//materialHighPassFilter: ShaderMaterial {uuid: \"031D54E9-22F3-4F42-8C31-EF4D970724C3\", name: \"\", type: \"ShaderMaterial\", fog: false, blending: 1, …}\n//separableBlurMaterials: (5) [ShaderMaterial, ShaderMaterial, ShaderMaterial, ShaderMaterial, ShaderMaterial]\n//compositeMaterial: ShaderMaterial {uuid: \"DBA670AF-AC33-428C-BAB3-91BE67FE2901\", name: \"\", type: \"ShaderMaterial\", fog: false, blending: 1, …}\n//bloomTintColors: (5) [Vector3, Vector3, Vector3, Vector3, Vector3]\n//copyUniforms: {tDiffuse: {…}, opacity: {…}}\n//materialCopy: ShaderMaterial {uuid: \"369D3C24-A73E-4576-BB78-E1261A5E6D64\", name: \"\", type: \"ShaderMaterial\", fog: false, blending: 2, …}\n//oldClearColor: Color {}\n//oldClearAlpha: 1\n","// Global imports -\nimport * as THREE from \"three\";\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n\nimport alertify  from \"alertifyjs\"\n\nimport Renderer from \"./components/renderer/main\";\nimport Nodes from \"./components/nodes/main\";\nimport Edges from \"./components/edges/main\";\n\nimport Keyboard from \"./interactions/keyboard\";\nimport DatGUI from './interactions/datGUI';\n\n\n/**\n * Class representing the  Graph\n * */\n export default class Graph {\n    /**\n     * @param  {string} Id of Canvas DOMElement\n     * @param  {string} Id of Canvas DOMElement\n     * @param  {bool}\n     * @param  {bool} If the graph should be ploted in 2d\n     * @return {Object} A random choiced element of the given array\n     */\n    constructor(\n        idCanvasHTML,\n        Config,\n        keyboardPressFunction,\n        use2d=false,\n        useHighQuality=true,\n        useBloom=true,\n        showStats=true,\n        camera={\n            fov: 40,\n            near: 2,\n            far: 1000,\n            aspect: 1,\n        },\n    ) {\n        this.Config = Config\n        this.use2d = use2d;\n        this.showStats = showStats;\n        this.useHighQuality = useHighQuality;\n        this.useBloom = useBloom;\n        this.idCanvasHTML = idCanvasHTML\n        this.canvas = document.getElementById(`${idCanvasHTML}`);\n        this.container = document.getElementById(`container${idCanvasHTML}`);\n        if(use2d){\n            this.camera = new THREE.OrthographicCamera(\n                2, -2, 2, -2, Config.camera.near, Config.camera.far);\n\n        }else{\n            this.camera = new THREE.PerspectiveCamera(\n                camera.fov, camera.aspect, 1, camera.far);\n        }\n\n        this.scene = new THREE.Scene();\n\n        this.renderer;\n        this.state;\n        this.keyboardPressFunction = keyboardPressFunction\n\n        //this.init = this.init.bind(this)\n    }\n    init(dataPool=false){\n        this.state = {\n            vimMode: \"Visual\",\n            isLoaded: false,\n            firstLoad: true,\n            takingScreenshot: false,\n            stopChanges: false,\n            renders: [],\n            comunityField:{},\n            rendering: false,\n            defaultProps: {}\n        }\n\n        let viewSize = 1;\n        var aspectRatio = window.innerWidth / window.innerHeight;\n        this.state.originalAspect = window.innerWidth / window.innerHeight;\n\n        this.scene.add(this.camera);\n\n        this.scene.background = new THREE.Color(this.Config.scene.color);\n\n        this.nodes = new Nodes(this.scene, this.use2d);\n        this.edges = new Edges(this.scene, 0, 1);\n\n\n        this.controls = new OrbitControls(this.camera, this.canvas);\n\n        this.controls.target.set(0, 0, 0);\n        this.controls.enableKeys=true;\n        this.controls.screenSpacePanning = true;\n        //this.controls.update();\n        if(this.use2d){\n\n            this.controls.enableRotate=false;\n            //this.controls.maxPolarAngle = 0; // radians\n            //this.controls.minAzimuthAngle = - 0; // radians\n            //this.controls.maxAzimuthAngle = 0; // radians\n\n        }\n\n        console.group(\"Render Init\")\n        this.renderer = new Renderer(\n            this.useHighQuality,\n            this.useBloom,\n            this.showStats,\n            this.scene, this.controls, this.container, this.canvas, this.camera, this.state,\n            dataPool);\n        console.groupEnd();\n\n        if (this.Config.useGuiControl)\n            this.datGui = new DatGUI(\n                this.idCanvasHTML,\n                this.scene,\n                this.renderer,\n                this.camera,\n                this.nodes,\n                this.edges,\n                this.Config,\n                this.state);\n\n        if (this.Config.useKeyboard)\n            this.keyboardInteraction = new Keyboard(\n                this.canvas,\n                this.state,\n                this.Config,\n                this.datGui.gui,\n                this.keyboardPressFunction,\n            );\n\n        //{\n        //const color = 0xffffff;\n        //const intensity = 4;\n        //const light = new THREE.DirectionalLight(color, intensity);\n        //light.position.set(-1, 2, 4);\n        //light.layers.enable(0)\n        //this.camera.add(light);\n        //}\n    }\n    /**\n     * Random select a element of a given array\n     */\n    ressetLook(){\n        let position = this.edges.instancedEdges.geometry.boundingSphere.center\n        this.camera.position.z = 4*this.edges.instancedEdges.geometry.boundingSphere.radius\n        //this.camera.position.z = 4;\n        this.camera.lookAt(position)\n        this.camera.updateProjectionMatrix();\n        this.renderer.render()\n    }\n    /**\n     * Random select a element of a given array\n     */\n    deleteGraph(){\n        this.nodes.deleteAllNodes()\n        this.edges.deleteAllEdges()\n    }\n    /**\n     * @param  {string} Id of Canvas DOMElement\n     * @param  {string} Id of Canvas DOMElement\n     * @param  {bool}\n     * @param  {bool} If the graph should be ploted in 2d\n     * @return {Object} A random choiced element of the given array\n     */\n    getURI(width, height, transparency){\n        transparency = transparency || false;\n        const uri = this.renderer.getURI(width, height, transparency);\n        this.uri = uri\n    }\n    /**\n     * Random select a element of a given array\n     */\n    stopRender(){\n        //this.deleteGraph();\n        this.renderer.stop();\n\n    }\n}\n\n\n","import alertify from \"alertifyjs\"\n\nimport Config from '../data/config';\nimport io from 'socket.io-client';\n\n\nexport default class DataPool {\n    constructor(address, listenerFunction) {\n        this.address = address;\n        this.ws = io.connect(`http://${address}/`);\n\n        \n       // this.ws.on(\"connect\",  (event)=>{ \n        //     alertify.success(\"opened connection\");\n        // })\n        this.ws.on(\"disconnect\",(event)=> {\n            alertify.warning(\"closed connection\");\n        })\n        ///this.ws.onerror = () => alertify.error(\"error connection\");\n        this.ws.on(\"webClientListener\",function(data){\n            listenerFunction(data)\n        });\n        this.ws.emit(\"joinRoom\", { room: \"webClient\" });\n\n        this.ws.emit(\"imTheProtagonist\");\n        this.getGraph = this.getGraph.bind(this)\n    }\n\n    isOpen() {\n        const open = this.ws.readyState === this.ws.OPEN\n        if (!open){\n            alertify.error(\"Connection Closed\")\n            console.error(\"Conection closed\")\n            this.ws = new WebSocket(`ws://${Config.address}/`);\n        }\n        return open\n    }\n\n    getGraph() {\n       // if (!this.isOpen()) return\n        this.ws.emit(\"getGraph\");\n    }\n    send2server(imgURI, time){\n        this.ws.emit(\"sendRenderedImg\", {\"imgURI\":imgURI, 'time':time})\n    }\n\n    deleteNodes(nodesId) {\n        console.info(\"deleteNodes\", nodesId)\n        if (!this.isOpen()) return\n        const message = {\n            type: \"deleteNodes\",\n            info: {\"nodesId\": nodesId}\n        };\n        this.ws.send(JSON.stringify(message));\n    }\n\n    reloadGraph(){\n        console.info(\"reload Graph\")\n        if (!this.isOpen()) return\n        const message = {\n            type: \"reloadGraph\",\n        };\n        this.ws.send(JSON.stringify(message));\n        //window.location.reload()\n    }\n\n\n    recalcPos() {\n        console.info(\"recalc pos\")\n        if (!this.isOpen()) return\n        const message = {\n            type: \"recalcPos\",\n        };\n        this.ws.send(JSON.stringify(message));\n    }\n}\n","\nimport Graph from './graph/main';\nimport Config from './data/config';\nimport DataPool from \"./connections/dataPool\";\n\n\nif (__ENV__ === 'dev') {\n  Config.isDev = true;\n}else{\n  Config.isDev = false;\n}\n\nfunction keyboardPressFunction(key, action) {\n\n        switch (action) {\n            case \"saveImg\":\n                $('#saveImageModal').modal(\"show\")\n            break;\n            case \"deleteNode\":\n                //let pickedObjectsNames = cameraObj.pickedObjects;\n                //if (pickedObjectsNames.length>0) {\n\n                //cameraObj.deleteHelpers();\n                //Config.vimMode = \"Visual\"\n                //dataPoolSocket.deleteNodes(pickedObjectsNames);\n                //pickedObjectsNames.map(nodeId=>nodes0.deleteNode(nodeId));\n                ////pickedObjectsNames.map(=>edges0.deleteByNode(nodeId));\n                //cameraObj.unpick();\n                //}\n\n                //render()\n                break;\n            case \"move\":\n                //let p = 0.1\n                //let dr = {\n                //\"l\" :[p, 0, 0],\n                //\"j\" :[-p, 0 ,0],\n                //\"i\": [0, p, 0],\n                //\"k\": [0, -p, 0]\n                //}[key.toLowerCase()]\n                //let pWorld =  new THREE.Vector3( dr[0], dr[1], -1 ).unproject( camera );\n                //nodes0.moveNodes({}, cameraObj.pickedObjects, dr)\n\n                //render()\n                break;\n            case \"recalcPos\":\n                dataPoolSocket.recalcPos()\n\n                break;\n\n            case \"reloadGraph\":\n                dataPoolSocket.reloadGraph()\n                break;\n\n            default:\n                break;\n        }\n    }\nfunction listenerFunction(message) {\n    //let message = JSON.parse(event.data);\n    switch (message[\"type\"]) {\n      case \"yourGraphData\":\n        clearInterval(intervalGetGraph);\n        //graphObj.state.defaultProps = message.defaultProps\n        //\n        console.group(\"getGraph\");\n        console.time(\"creatingEdges\");\n\n        console.group(\"createEdges\");\n        graphObj.edges.createEdges(\n          message.nodes,\n          message.edges,\n          message.defaultProps\n        );\n        console.groupEnd();\n        console.timeEnd(\"creatingEdges\");\n\n        console.group(\"createNodes\");\n        console.time(\"creatingNodes\");\n        graphObj.nodes.createNodes(message.nodes, true);\n        console.timeEnd(\"creatingNodes\");\n        console.groupEnd();\n        if (graphObj.state.firstLoad) {\n          graphObj.firstLoad = false;\n          graphObj.ressetLook();\n          clearInterval(intervalGetGraph);\n        }\n\n        graphObj.nodes.stopUpdate();\n        //let nodes = JSON.parse(JSON.stringify(message.nodes))\n        //nodes.pos = nodes.pos.map((p)=>p*0.3);\n        //graphObj.nodes.createNodes(nodes, false);\n        //\n        //camera.position.set(0, nodes0.max_vals[2] * (1 + 2), 0);\n        graphObj.datGui.updateNodeColorProp(message.nodes.props);\n        graphObj.datGui.updateComunityField(\n          Object.keys(graphObj.nodes.nodesGroup)\n        );\n        //datGui.updateEdgeColorProp(message.edges.props)\n        //camera.lookAt(nodes0.instancedNodes);\n        console.groupEnd();\n\n        break;\n\n      case \"addNodes\":\n        graphObj.nodes.createNodes(message.nodes, false);\n        if (graphObj.state.firstLoad) {\n          graphObj.firstLoad = false;\n          graphObj.ressetLook();\n          clearInterval(intervalGetGraph);\n        }\n\n        break;\n      case \"deleteNodes\":\n        //message.info.nodesId.map(nodeId=>nodes0.deleteNode(nodeId));\n        //message.info.edgesName.map(edgeName=>edges0.deleteEdge(edgeName));\n        ////dataPoolSocket.recalcPos();\n        ////\n        //render()\n        break;\n\n      case \"updatePos\":\n        graphObj.nodes.updateNodePositions(message.info.pos);\n        graphObj.edges.updateNodePositions(message.info.pos);\n        graphObj.renderer.render();\n        break;\n\n      case \"askToRenderMyImg\":\n        const dataURI = graphObj.renderer.takeScreenshot(\n          message[\"width\"],\n          message[\"height\"],\n          message[\"transparency\"]\n        );\n        dataPoolSocket.send2server(dataURI, message[\"time\"]);\n        break;\n      case \"updateNodeColors\":\n        graphObj.nodes.updateColors(message.colors, 'main');\n        graphObj.renderer.render();\n        break;\n\n      default:\n        break;\n    }\n\n\n}\nconst queryString = window.location.search;\nconst urlParams = new URLSearchParams(queryString);\n\nconsole.info(queryString);\nconst useHighQuality = urlParams.has('highQuality')? urlParams.get('highQuality')=='1': false;\nconst useBloom = urlParams.has('bloom')? urlParams.get('bloom')=='1': true;\nconst use2d = urlParams.has('use2d')? urlParams.get('use2d')=='1': false;\nconst address = urlParams.has('address')? urlParams.get('address'): 'localhost:5000';\nconst showStats = urlParams.has('stats')? urlParams.get('stats')=='1': false;\n\nConfig.useGuiControl = true;\n\nconst graphObj = new Graph(\n    \"graphCanvas\",\n    Config,\n    keyboardPressFunction,\n    use2d,\n    useHighQuality,\n    useBloom,\n    showStats\n)\nwindow.graphObjVar = graphObj;\n\nconsole.group('Socket Conection');\n\nconsole.info('Address:', address);\n\nlet dataPoolSocket = new DataPool(address, listenerFunction);\ngraphObj.init(dataPoolSocket)\nconst intervalGetGraph = setInterval(() => {\n    dataPoolSocket.getGraph();\n}, 1000);\n\nconsole.groupEnd();\n"],"sourceRoot":""}